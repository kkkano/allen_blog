<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F1åˆ†æ•°ä¸é˜ˆå€¼é€‰æ‹©</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            min-height: 0;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 2em;
        }
        .subtitle {
            text-align: center;
            color: #718096;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f7fafc;
            border-radius: 12px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
            font-size: 0.9em;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #f5576c;
            cursor: pointer;
            transition: all 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #e53e3e;
            transform: scale(1.2);
        }
        .value-display {
            display: inline-block;
            background: #f5576c;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 10px;
        }
        .plot-container {
            margin-bottom: 30px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 8px;
        }
        .metric-value {
            font-size: 2em;
            font-weight: 700;
        }
        .info-box {
            background: #f7fafc;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #f5576c;
        }
        .info-box h3 {
            margin-top: 0;
            color: #2d3748;
        }
        .formula {
            background: white;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border: 1px solid #e2e8f0;
        }
        @media (prefers-color-scheme: dark) {
            body {
                background: linear-gradient(135deg, #1a202c 0%, #2d3748 100%);
            }
            .container {
                background: #2d3748;
                color: #e2e8f0;
            }
            h1, label, .info-box h3 {
                color: #e2e8f0;
            }
            .subtitle {
                color: #a0aec0;
            }
            .controls, .info-box {
                background: #1a202c;
            }
            .formula {
                background: #2d3748;
                border-color: #4a5568;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“ˆ F1åˆ†æ•°ä¸é˜ˆå€¼é€‰æ‹©</h1>
        <p class="subtitle">ç†è§£ç²¾ç¡®ç‡ã€å¬å›ç‡ä¸F1åˆ†æ•°çš„æƒè¡¡</p>

        <div class="controls">
            <div class="control-group">
                <label>
                    çœŸå¼‚å¸¸æ•°é‡: <span class="value-display" id="trueAnomaliesValue">50</span>
                </label>
                <input type="range" id="trueAnomaliesSlider" min="10" max="100" step="5" value="50">
            </div>

            <div class="control-group">
                <label>
                    æ€»æ ·æœ¬æ•°: <span class="value-display" id="totalSamplesValue">500</span>
                </label>
                <input type="range" id="totalSamplesSlider" min="200" max="1000" step="50" value="500">
            </div>

            <div class="control-group">
                <label>
                    å½“å‰é˜ˆå€¼ Îµ: <span class="value-display" id="currentThresholdValue">0.05</span>
                </label>
                <input type="range" id="currentThresholdSlider" min="0.001" max="0.2" step="0.001" value="0.05">
            </div>
        </div>

        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">ç²¾ç¡®ç‡ (Precision)</div>
                <div class="metric-value" id="precisionValue">0.00</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">å¬å›ç‡ (Recall)</div>
                <div class="metric-value" id="recallValue">0.00</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">F1åˆ†æ•°</div>
                <div class="metric-value" id="f1Value">0.00</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">æœ€ä½³F1åˆ†æ•°</div>
                <div class="metric-value" id="bestF1Value">0.00</div>
            </div>
        </div>

        <div class="plot-container" id="f1Plot"></div>
        <div class="plot-container" id="confusionMatrix"></div>

        <div class="info-box">
            <h3>å…¬å¼è¯´æ˜</h3>
            <div class="formula">
                ç²¾ç¡®ç‡ (Precision) = TP / (TP + FP)
            </div>
            <div class="formula">
                å¬å›ç‡ (Recall) = TP / (TP + FN)
            </div>
            <div class="formula">
                F1åˆ†æ•° = 2 Ã— (Precision Ã— Recall) / (Precision + Recall)
            </div>
            <p style="margin-top: 15px; color: #4a5568;">
                <strong>TP</strong>: çœŸæ­£ä¾‹ï¼ˆæ­£ç¡®è¯†åˆ«çš„å¼‚å¸¸ï¼‰<br>
                <strong>FP</strong>: å‡æ­£ä¾‹ï¼ˆè¯¯æŠ¥ä¸ºå¼‚å¸¸ï¼‰<br>
                <strong>FN</strong>: å‡è´Ÿä¾‹ï¼ˆæ¼æŠ¥çš„å¼‚å¸¸ï¼‰<br>
                <strong>TN</strong>: çœŸè´Ÿä¾‹ï¼ˆæ­£ç¡®è¯†åˆ«çš„æ­£å¸¸æ ·æœ¬ï¼‰
            </p>
        </div>
    </div>

    <script>
        function gaussianPDF(x, mu, sigma) {
            const coefficient = 1 / (sigma * Math.sqrt(2 * Math.PI));
            const exponent = -Math.pow(x - mu, 2) / (2 * Math.pow(sigma, 2));
            return coefficient * Math.exp(exponent);
        }

        function randomGaussian(mu, sigma) {
            let u1 = Math.random();
            let u2 = Math.random();
            let z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return z0 * sigma + mu;
        }

        function calculateMetrics(threshold, samples, trueAnomalies) {
            let tp = 0, fp = 0, fn = 0, tn = 0;

            samples.forEach(sample => {
                const predicted = sample.prob < threshold;
                const actual = sample.isAnomaly;

                if (predicted && actual) tp++;
                else if (predicted && !actual) fp++;
                else if (!predicted && actual) fn++;
                else tn++;
            });

            const precision = tp + fp > 0 ? tp / (tp + fp) : 0;
            const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
            const f1 = precision + recall > 0 ? 2 * precision * recall / (precision + recall) : 0;

            return { tp, fp, fn, tn, precision, recall, f1 };
        }

        function updateVisualization() {
            const trueAnomalies = parseInt(document.getElementById('trueAnomaliesSlider').value);
            const totalSamples = parseInt(document.getElementById('totalSamplesSlider').value);
            const currentThreshold = parseFloat(document.getElementById('currentThresholdSlider').value);

            document.getElementById('trueAnomaliesValue').textContent = trueAnomalies;
            document.getElementById('totalSamplesValue').textContent = totalSamples;
            document.getElementById('currentThresholdValue').textContent = currentThreshold.toFixed(3);

            // ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
            const samples = [];
            const mu = 0, sigma = 1;

            // ç”Ÿæˆæ­£å¸¸æ ·æœ¬
            for (let i = 0; i < totalSamples - trueAnomalies; i++) {
                const x = randomGaussian(mu, sigma);
                const prob = gaussianPDF(x, mu, sigma);
                samples.push({ prob, isAnomaly: false });
            }

            // ç”Ÿæˆå¼‚å¸¸æ ·æœ¬ï¼ˆè¿œç¦»å‡å€¼ï¼‰
            for (let i = 0; i < trueAnomalies; i++) {
                const x = randomGaussian(mu + 3, sigma * 0.5);
                const prob = gaussianPDF(x, mu, sigma);
                samples.push({ prob, isAnomaly: true });
            }

            // è®¡ç®—ä¸åŒé˜ˆå€¼ä¸‹çš„F1åˆ†æ•°
            const thresholds = [];
            const precisions = [];
            const recalls = [];
            const f1Scores = [];

            const minProb = Math.min(...samples.map(s => s.prob));
            const maxProb = Math.max(...samples.map(s => s.prob));
            const step = (maxProb - minProb) / 100;

            let bestF1 = 0;
            let bestThreshold = 0;

            for (let threshold = minProb; threshold <= maxProb; threshold += step) {
                const metrics = calculateMetrics(threshold, samples, trueAnomalies);
                thresholds.push(threshold);
                precisions.push(metrics.precision);
                recalls.push(metrics.recall);
                f1Scores.push(metrics.f1);

                if (metrics.f1 > bestF1) {
                    bestF1 = metrics.f1;
                    bestThreshold = threshold;
                }
            }

            // è®¡ç®—å½“å‰é˜ˆå€¼çš„æŒ‡æ ‡
            const currentMetrics = calculateMetrics(currentThreshold, samples, trueAnomalies);

            document.getElementById('precisionValue').textContent = currentMetrics.precision.toFixed(3);
            document.getElementById('recallValue').textContent = currentMetrics.recall.toFixed(3);
            document.getElementById('f1Value').textContent = currentMetrics.f1.toFixed(3);
            document.getElementById('bestF1Value').textContent = bestF1.toFixed(3);

            // ç»˜åˆ¶F1åˆ†æ•°æ›²çº¿
            const trace1 = {
                x: thresholds,
                y: f1Scores,
                type: 'scatter',
                mode: 'lines',
                name: 'F1åˆ†æ•°',
                line: { color: '#f5576c', width: 3 }
            };

            const trace2 = {
                x: thresholds,
                y: precisions,
                type: 'scatter',
                mode: 'lines',
                name: 'ç²¾ç¡®ç‡',
                line: { color: '#48bb78', width: 2 }
            };

            const trace3 = {
                x: thresholds,
                y: recalls,
                type: 'scatter',
                mode: 'lines',
                name: 'å¬å›ç‡',
                line: { color: '#4299e1', width: 2 }
            };

            const trace4 = {
                x: [currentThreshold, currentThreshold],
                y: [0, 1],
                type: 'scatter',
                mode: 'lines',
                name: 'å½“å‰é˜ˆå€¼',
                line: { color: '#805ad5', width: 2, dash: 'dash' }
            };

            const trace5 = {
                x: [bestThreshold, bestThreshold],
                y: [0, 1],
                type: 'scatter',
                mode: 'lines',
                name: 'æœ€ä½³é˜ˆå€¼',
                line: { color: '#ed8936', width: 2, dash: 'dot' }
            };

            const layout1 = {
                title: 'F1åˆ†æ•°ã€ç²¾ç¡®ç‡ä¸å¬å›ç‡éšé˜ˆå€¼å˜åŒ–',
                xaxis: { title: 'é˜ˆå€¼ Îµ' },
                yaxis: { title: 'åˆ†æ•°', range: [0, 1] },
                hovermode: 'closest',
                plot_bgcolor: '#f7fafc',
                paper_bgcolor: 'white'
            };

            Plotly.newPlot('f1Plot', [trace1, trace2, trace3, trace4, trace5], layout1, {responsive: true});

            // ç»˜åˆ¶æ··æ·†çŸ©é˜µ
            const confusionData = [
                {
                    z: [[currentMetrics.tn, currentMetrics.fp],
                        [currentMetrics.fn, currentMetrics.tp]],
                    x: ['é¢„æµ‹æ­£å¸¸', 'é¢„æµ‹å¼‚å¸¸'],
                    y: ['å®é™…æ­£å¸¸', 'å®é™…å¼‚å¸¸'],
                    type: 'heatmap',
                    colorscale: [
                        [0, '#e6f7ff'],
                        [1, '#0050b3']
                    ],
                    showscale: true,
                    text: [[`TN: ${currentMetrics.tn}`, `FP: ${currentMetrics.fp}`],
                           [`FN: ${currentMetrics.fn}`, `TP: ${currentMetrics.tp}`]],
                    texttemplate: '%{text}',
                    textfont: { size: 16, color: 'white' }
                }
            ];

            const layout2 = {
                title: 'æ··æ·†çŸ©é˜µ',
                xaxis: { title: 'é¢„æµ‹æ ‡ç­¾' },
                yaxis: { title: 'çœŸå®æ ‡ç­¾' },
                plot_bgcolor: '#f7fafc',
                paper_bgcolor: 'white'
            };

            Plotly.newPlot('confusionMatrix', confusionData, layout2, {responsive: true});
        }

        document.getElementById('trueAnomaliesSlider').addEventListener('input', updateVisualization);
        document.getElementById('totalSamplesSlider').addEventListener('input', updateVisualization);
        document.getElementById('currentThresholdSlider').addEventListener('input', updateVisualization);

        function reportHeight() {
            const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
            window.parent.postMessage({ type: 'iframe-height', height }, '*');
        }

        updateVisualization();
        window.addEventListener('load', () => {
            reportHeight();
            const ro = new ResizeObserver(reportHeight);
            ro.observe(document.body);
            ro.observe(document.documentElement);
            setTimeout(reportHeight, 120);
        });
    </script>
</body>
</html>
