<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åå·®-æ–¹å·®æƒè¡¡å¯è§†åŒ–</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1d4ed8 0%, #0f766e 100%);
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 14px 36px rgba(15, 23, 42, 0.12);
        }
        h1 {
            color: #1d4ed8;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        .controls {
            background: #f4f8ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #1d4ed8;
            cursor: pointer;
        }
        .value-display {
            display: inline-block;
            background: #1d4ed8;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .metric-card {
            background: linear-gradient(135deg, #1d4ed8 0%, #0f766e 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .metric-value {
            font-size: 28px;
            font-weight: bold;
            margin: 10px 0;
        }
        .metric-label {
            font-size: 14px;
            opacity: 0.9;
        }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }
        .status-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status-good { background: #4caf50; color: white; }
        .status-warning { background: #ff9800; color: white; }
        .status-bad { background: #f44336; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“Š åå·®-æ–¹å·®æƒè¡¡å¯è§†åŒ–</h1>
        <p class="subtitle">æ¢ç´¢æ¨¡å‹å¤æ‚åº¦å¦‚ä½•å½±å“æ¬ æ‹Ÿåˆå’Œè¿‡æ‹Ÿåˆ</p>

        <div class="controls">
            <div class="control-group">
                <label>
                    å¤šé¡¹å¼é˜¶æ•° (Model Complexity):
                    <span class="value-display" id="degreeValue">1</span>
                    <span class="status-indicator" id="statusIndicator">æ¬ æ‹Ÿåˆ</span>
                </label>
                <input type="range" id="degree" min="1" max="15" step="1" value="1">
            </div>
            <div class="control-group">
                <label>
                    æ•°æ®å™ªå£°æ°´å¹³:
                    <span class="value-display" id="noiseValue">0.3</span>
                </label>
                <input type="range" id="noise" min="0.1" max="1.0" step="0.1" value="0.3">
            </div>
            <div class="control-group">
                <label>
                    è®­ç»ƒæ ·æœ¬æ•°é‡:
                    <span class="value-display" id="samplesValue">30</span>
                </label>
                <input type="range" id="samples" min="10" max="100" step="10" value="30">
            </div>
        </div>

        <div class="metrics">
            <div class="metric-card">
                <div class="metric-label">è®­ç»ƒè¯¯å·®</div>
                <div class="metric-value" id="trainError">-</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">éªŒè¯è¯¯å·®</div>
                <div class="metric-value" id="valError">-</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">è¯¯å·®æ¯”å€¼</div>
                <div class="metric-value" id="errorRatio">-</div>
            </div>
        </div>

        <div id="fittingChart"></div>
        <div id="errorChart"></div>

        <div class="info-box">
            <strong>ğŸ¯ å…³é”®æ´å¯Ÿï¼š</strong>
            <ul>
                <li><strong>æ¬ æ‹Ÿåˆï¼ˆé«˜åå·®ï¼‰</strong>: é˜¶æ•°1-2æ—¶ï¼Œæ¨¡å‹è¿‡äºç®€å•ï¼Œè®­ç»ƒå’ŒéªŒè¯è¯¯å·®éƒ½å¾ˆé«˜</li>
                <li><strong>æœ€ä¼˜æ‹Ÿåˆ</strong>: é˜¶æ•°3-5æ—¶ï¼Œæ¨¡å‹å¤æ‚åº¦é€‚ä¸­ï¼ŒéªŒè¯è¯¯å·®æœ€ä½</li>
                <li><strong>è¿‡æ‹Ÿåˆï¼ˆé«˜æ–¹å·®ï¼‰</strong>: é˜¶æ•°>8æ—¶ï¼Œè®­ç»ƒè¯¯å·®å¾ˆä½ä½†éªŒè¯è¯¯å·®æ¿€å¢</li>
                <li><strong>åˆ¤æ–­æ ‡å‡†</strong>: å½“éªŒè¯è¯¯å·® > 2Ã—è®­ç»ƒè¯¯å·®æ—¶ï¼Œè¯´æ˜è¿‡æ‹Ÿåˆä¸¥é‡</li>
            </ul>
        </div>
    </div>

    <script>
        // ç”ŸæˆçœŸå®å‡½æ•°ï¼ˆä¸‰æ¬¡å¤šé¡¹å¼ï¼‰
        function trueFunction(x) {
            return 0.5 * x**3 - 2 * x**2 + x + 3;
        }

        // ç”Ÿæˆè®­ç»ƒæ•°æ®
        function generateData(n, noise) {
            const X = [];
            const y = [];
            for (let i = 0; i < n; i++) {
                const x = Math.random() * 4 - 2;
                const yTrue = trueFunction(x);
                const yNoisy = yTrue + (Math.random() - 0.5) * noise * 10;
                X.push(x);
                y.push(yNoisy);
            }
            return { X, y };
        }

        // å¤šé¡¹å¼æ‹Ÿåˆï¼ˆç®€åŒ–ç‰ˆæœ€å°äºŒä¹˜æ³•ï¼‰
        function polynomialFit(X, y, degree) {
            // æ„å»ºè®¾è®¡çŸ©é˜µ
            const n = X.length;
            const A = [];
            for (let i = 0; i < n; i++) {
                const row = [];
                for (let j = 0; j <= degree; j++) {
                    row.push(Math.pow(X[i], j));
                }
                A.push(row);
            }

            // ä½¿ç”¨æ­£è§„æ–¹ç¨‹æ±‚è§£ï¼ˆç®€åŒ–å®ç°ï¼‰
            // å®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨æ•°å€¼ç¨³å®šçš„æ–¹æ³•
            const coeffs = Array(degree + 1).fill(0);

            // ç®€åŒ–çš„æ¢¯åº¦ä¸‹é™æ±‚è§£
            const lr = 0.001;
            const iterations = 1000;

            for (let iter = 0; iter < iterations; iter++) {
                const gradients = Array(degree + 1).fill(0);

                for (let i = 0; i < n; i++) {
                    let pred = 0;
                    for (let j = 0; j <= degree; j++) {
                        pred += coeffs[j] * Math.pow(X[i], j);
                    }
                    const error = pred - y[i];

                    for (let j = 0; j <= degree; j++) {
                        gradients[j] += error * Math.pow(X[i], j);
                    }
                }

                for (let j = 0; j <= degree; j++) {
                    coeffs[j] -= lr * gradients[j] / n;
                }
            }

            return coeffs;
        }

        // é¢„æµ‹
        function predict(x, coeffs) {
            let y = 0;
            for (let i = 0; i < coeffs.length; i++) {
                y += coeffs[i] * Math.pow(x, i);
            }
            return y;
        }

        // è®¡ç®—MSE
        function mse(X, y, coeffs) {
            let sum = 0;
            for (let i = 0; i < X.length; i++) {
                const pred = predict(X[i], coeffs);
                sum += Math.pow(pred - y[i], 2);
            }
            return sum / X.length;
        }

        function safeFinite(value, fallback = 0) {
            return Number.isFinite(value) ? value : fallback;
        }

        function build2DLayout(layout) {
            const axisBase = {
                gridcolor: '#dbe6f8',
                zerolinecolor: '#c5d6f3',
                linecolor: '#8ea9de',
                tickcolor: '#8ea9de',
                ticks: 'outside',
                automargin: true,
            };

            return {
                paper_bgcolor: '#f8fbff',
                plot_bgcolor: '#f8fbff',
                font: { color: '#0f172a' },
                margin: { t: 56, r: 24, b: 52, l: 60 },
                ...layout,
                xaxis: {
                    ...axisBase,
                    ...(layout?.xaxis || {}),
                },
                yaxis: {
                    ...axisBase,
                    ...(layout?.yaxis || {}),
                },
            };
        }


        function updateVisualization() {
            const degree = parseInt(document.getElementById('degree').value);
            const noise = parseFloat(document.getElementById('noise').value);
            const nSamples = parseInt(document.getElementById('samples').value);

            document.getElementById('degreeValue').textContent = degree;
            document.getElementById('noiseValue').textContent = noise.toFixed(1);
            document.getElementById('samplesValue').textContent = nSamples;

            // ç”Ÿæˆæ•°æ®
            const trainData = generateData(nSamples, noise);
            const valData = generateData(30, noise);

            // æ‹Ÿåˆæ¨¡å‹
            const coeffs = polynomialFit(trainData.X, trainData.y, degree);

            // è®¡ç®—è¯¯å·®
            const trainError = mse(trainData.X, trainData.y, coeffs);
            const valError = mse(valData.X, valData.y, coeffs);
            const ratio = valError / trainError;

            document.getElementById('trainError').textContent = trainError.toFixed(3);
            document.getElementById('valError').textContent = valError.toFixed(3);
            document.getElementById('errorRatio').textContent = ratio.toFixed(2) + 'x';

            // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
            const statusElem = document.getElementById('statusIndicator');
            if (degree <= 2) {
                statusElem.textContent = 'æ¬ æ‹Ÿåˆ';
                statusElem.className = 'status-indicator status-bad';
            } else if (degree <= 5) {
                statusElem.textContent = 'æœ€ä¼˜æ‹Ÿåˆ';
                statusElem.className = 'status-indicator status-good';
            } else {
                statusElem.textContent = 'è¿‡æ‹Ÿåˆ';
                statusElem.className = 'status-indicator status-warning';
            }

            // ç»˜åˆ¶æ‹Ÿåˆæ›²çº¿
            const xRange = [];
            const yTrue = [];
            const yPred = [];
            for (let x = -2; x <= 2; x += 0.05) {
                xRange.push(x);
                yTrue.push(trueFunction(x));
                yPred.push(safeFinite(predict(x, coeffs), null));
            }

            const trace1 = {
                x: trainData.X,
                y: trainData.y,
                mode: 'markers',
                type: 'scatter',
                name: 'è®­ç»ƒæ•°æ®',
                marker: { size: 8, color: '#1d4ed8' }
            };

            const trace2 = {
                x: xRange,
                y: yTrue,
                mode: 'lines',
                type: 'scatter',
                name: 'çœŸå®å‡½æ•°',
                line: { color: '#4caf50', width: 3, dash: 'dash' }
            };

            const trace3 = {
                x: xRange,
                y: yPred,
                mode: 'lines',
                type: 'scatter',
                name: `æ‹Ÿåˆæ›²çº¿ (é˜¶æ•°=${degree})`,
                line: { color: '#f44336', width: 3 }
            };

            Plotly.newPlot('fittingChart', [trace1, trace2, trace3], build2DLayout({
                title: 'å¤šé¡¹å¼æ‹Ÿåˆæ•ˆæœ',
                xaxis: { title: 'x' },
                yaxis: { title: 'y' },
                height: 400
            }));

            // ç»˜åˆ¶è¯¯å·®æ›²çº¿ï¼ˆä¸åŒé˜¶æ•°ï¼‰
            const degrees = Array.from({ length: 15 }, (_, i) => i + 1);
            const trainErrors = [];
            const valErrors = [];

            for (let d of degrees) {
                const c = polynomialFit(trainData.X, trainData.y, d);
                trainErrors.push(mse(trainData.X, trainData.y, c));
                valErrors.push(mse(valData.X, valData.y, c));
            }

            const trace4 = {
                x: degrees,
                y: trainErrors,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'è®­ç»ƒè¯¯å·®',
                line: { color: '#1d4ed8', width: 3 }
            };

            const trace5 = {
                x: degrees,
                y: valErrors,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'éªŒè¯è¯¯å·®',
                line: { color: '#f44336', width: 3 }
            };

            Plotly.newPlot('errorChart', [trace4, trace5], build2DLayout({
                title: 'è¯¯å·®éšæ¨¡å‹å¤æ‚åº¦å˜åŒ–',
                xaxis: { title: 'å¤šé¡¹å¼é˜¶æ•°' },
                yaxis: { title: 'MSE' },
                height: 400,
                shapes: [{
                    type: 'line',
                    x0: degree,
                    x1: degree,
                    y0: 0,
                    y1: Math.max(...valErrors.filter(Number.isFinite), 1),
                    line: { color: 'gray', width: 2, dash: 'dot' }
                }]
            }));
        }

        // äº‹ä»¶ç›‘å¬
        document.getElementById('degree').addEventListener('input', updateVisualization);
        document.getElementById('noise').addEventListener('input', updateVisualization);
        document.getElementById('samples').addEventListener('input', updateVisualization);

        // åˆå§‹åŒ–
        updateVisualization();
    </script>

<script>
(function () {
  const sendHeight = () => {
    if (window.parent === window) return;
    const body = document.body;
    const root = document.documentElement;
    const height = Math.max(
      body ? body.scrollHeight : 0,
      body ? body.offsetHeight : 0,
      root ? root.scrollHeight : 0,
      root ? root.offsetHeight : 0
    );
    window.parent.postMessage({ type: 'iframe-height', height }, '*');
  };

  window.addEventListener('load', sendHeight);
  window.addEventListener('resize', sendHeight);

  if ('ResizeObserver' in window) {
    const observer = new ResizeObserver(sendHeight);
    if (document.body) observer.observe(document.body);
    if (document.documentElement) observer.observe(document.documentElement);
  }

  requestAnimationFrame(sendHeight);
  setTimeout(sendHeight, 250);
  setTimeout(sendHeight, 1000);
})();
</script>
</body>
</html>
