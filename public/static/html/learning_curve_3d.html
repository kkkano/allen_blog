<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å­¦ä¹ æ›²çº¿3Då¯è§†åŒ–</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1d4ed8 0%, #0f766e 100%);
        }
        .container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 14px 36px rgba(15, 23, 42, 0.12);
        }
        h1 {
            color: #1d4ed8;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
        }
        .controls {
            background: #f4f8ff;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #333;
        }
        select {
            width: 100%;
            padding: 10px;
            border: 2px solid #1d4ed8;
            border-radius: 5px;
            font-size: 14px;
        }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }
        .recommendation {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-top: 15px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“ˆ å­¦ä¹ æ›²çº¿3Då¯è§†åŒ–</h1>
        <p class="subtitle">æ¢ç´¢è®­ç»ƒé›†å¤§å°ã€æ¨¡å‹å¤æ‚åº¦ä¸è¯¯å·®çš„ä¸‰ç»´å…³ç³»</p>

        <div class="controls">
            <div class="control-group">
                <label>é€‰æ‹©å¯è§†åŒ–æ¨¡å¼ï¼š</label>
                <select id="viewMode" onchange="updateVisualization()">
                    <option value="3d">3Dæ›²é¢å›¾ï¼ˆè®­ç»ƒé›†å¤§å° Ã— æ¨¡å‹å¤æ‚åº¦ Ã— è¯¯å·®ï¼‰</option>
                    <option value="learning_curve">å­¦ä¹ æ›²çº¿ï¼ˆå›ºå®šæ¨¡å‹å¤æ‚åº¦ï¼‰</option>
                    <option value="complexity_curve">å¤æ‚åº¦æ›²çº¿ï¼ˆå›ºå®šè®­ç»ƒé›†å¤§å°ï¼‰</option>
                    <option value="heatmap">çƒ­åŠ›å›¾ï¼ˆè¯¯å·®åˆ†å¸ƒï¼‰</option>
                </select>
            </div>
            <div class="control-group">
                <label>æ¨¡å‹ç±»å‹ï¼š</label>
                <select id="modelType" onchange="updateVisualization()">
                    <option value="polynomial">å¤šé¡¹å¼å›å½’</option>
                    <option value="neural_network">ç¥ç»ç½‘ç»œ</option>
                </select>
            </div>
        </div>

        <div id="mainChart"></div>

        <div class="recommendation" id="recommendation"></div>

        <div class="info-box">
            <strong>ğŸ” å…³é”®æ´å¯Ÿï¼š</strong>
            <ul>
                <li><strong>å°æ•°æ®é›†ï¼ˆ<50æ ·æœ¬ï¼‰</strong>: é«˜æ–¹å·®é—®é¢˜ä¸¥é‡ï¼ŒéªŒè¯è¯¯å·®æ³¢åŠ¨å¤§</li>
                <li><strong>ä¸­ç­‰æ•°æ®é›†ï¼ˆ50-200æ ·æœ¬ï¼‰</strong>: è¯¯å·®å¿«é€Ÿä¸‹é™ï¼Œæ•°æ®å¢ç›Šæ˜æ˜¾</li>
                <li><strong>å¤§æ•°æ®é›†ï¼ˆ>200æ ·æœ¬ï¼‰</strong>: è¯¯å·®è¶‹äºå¹³ç¨³ï¼Œç»§ç»­å¢åŠ æ•°æ®æ”¶ç›Šé€’å‡</li>
                <li><strong>æ¨¡å‹å¤æ‚åº¦å½±å“</strong>: ç®€å•æ¨¡å‹å—æ•°æ®é‡å½±å“å°ï¼Œå¤æ‚æ¨¡å‹éœ€è¦æ›´å¤šæ•°æ®</li>
                <li><strong>åˆ¤æ–­æ ‡å‡†</strong>: å¦‚æœæ›²çº¿æœªæ”¶æ•›ä¸”è®­ç»ƒ/éªŒè¯è¯¯å·®å·®è·å¤§ï¼Œéœ€è¦æ›´å¤šæ•°æ®</li>
            </ul>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿå­¦ä¹ æ›²çº¿æ•°æ®ç”Ÿæˆ
        function generateLearningCurveData(modelComplexity, maxSamples = 300) {
            const trainSizes = [];
            const trainErrors = [];
            const valErrors = [];

            for (let n = 10; n <= maxSamples; n += 10) {
                trainSizes.push(n);

                // è®­ç»ƒè¯¯å·®ï¼šéšæ ·æœ¬å¢åŠ è€Œå¢åŠ ï¼ˆæ¨¡å‹éš¾ä»¥å®Œç¾æ‹Ÿåˆæ›´å¤šæ•°æ®ï¼‰
                const trainError = 0.1 + 0.3 * Math.exp(-n / 50) +
                                   0.05 * Math.random();
                trainErrors.push(trainError);

                // éªŒè¯è¯¯å·®ï¼šéšæ ·æœ¬å¢åŠ è€Œå‡å°‘ï¼ˆæ³›åŒ–èƒ½åŠ›æå‡ï¼‰
                const baseValError = 0.5 + 0.5 * Math.exp(-n / 80);
                const complexityPenalty = modelComplexity > 5 ?
                    0.3 * Math.exp(-n / 100) : 0;
                const valError = baseValError + complexityPenalty +
                                0.08 * Math.random();
                valErrors.push(valError);
            }

            return { trainSizes, trainErrors, valErrors };
        }

        // ç”Ÿæˆ3Dæ›²é¢æ•°æ®
        function generate3DSurfaceData() {
            const trainSizes = Array.from({ length: 20 }, (_, i) => 20 + i * 15);
            const complexities = Array.from({ length: 15 }, (_, i) => i + 1);

            const trainErrorSurface = [];
            const valErrorSurface = [];

            for (let complexity of complexities) {
                const trainRow = [];
                const valRow = [];

                for (let n of trainSizes) {
                    // è®­ç»ƒè¯¯å·®
                    const trainError = 0.1 + 0.3 * Math.exp(-n / 50) +
                                      0.02 * complexity / 15;
                    trainRow.push(trainError);

                    // éªŒè¯è¯¯å·®
                    const baseValError = 0.5 + 0.5 * Math.exp(-n / 80);
                    const complexityPenalty = complexity > 5 ?
                        0.4 * Math.exp(-n / 100) * (complexity - 5) / 10 : 0;
                    const valError = baseValError + complexityPenalty;
                    valRow.push(valError);
                }

                trainErrorSurface.push(trainRow);
                valErrorSurface.push(valRow);
            }

            return { trainSizes, complexities, trainErrorSurface, valErrorSurface };
        }

        function build2DLayout(layout) {
            const axisBase = {
                gridcolor: '#dbe6f8',
                zerolinecolor: '#c5d6f3',
                linecolor: '#8ea9de',
                tickcolor: '#8ea9de',
                ticks: 'outside',
                automargin: true,
            };

            return {
                paper_bgcolor: '#f8fbff',
                plot_bgcolor: '#f8fbff',
                font: { color: '#0f172a' },
                margin: { t: 56, r: 24, b: 52, l: 60 },
                ...layout,
                xaxis: {
                    ...axisBase,
                    ...(layout?.xaxis || {}),
                },
                yaxis: {
                    ...axisBase,
                    ...(layout?.yaxis || {}),
                },
            };
        }

        function build3DLayout(layout) {
            const sceneAxis = {
                showbackground: true,
                backgroundcolor: '#f8fbff',
                gridcolor: '#dbe6f8',
                zerolinecolor: '#c5d6f3',
                linecolor: '#8ea9de',
                tickcolor: '#8ea9de',
            };

            const currentScene = layout?.scene || {};

            return {
                paper_bgcolor: '#f8fbff',
                plot_bgcolor: '#f8fbff',
                font: { color: '#0f172a' },
                margin: { t: 56, r: 24, b: 30, l: 24 },
                ...layout,
                scene: {
                    bgcolor: '#f8fbff',
                    ...currentScene,
                    xaxis: {
                        ...sceneAxis,
                        ...(currentScene.xaxis || {}),
                    },
                    yaxis: {
                        ...sceneAxis,
                        ...(currentScene.yaxis || {}),
                    },
                    zaxis: {
                        ...sceneAxis,
                        ...(currentScene.zaxis || {}),
                    },
                },
            };
        }



        function updateVisualization() {
            const viewMode = document.getElementById('viewMode').value;
            const modelType = document.getElementById('modelType').value;

            if (viewMode === '3d') {
                plot3DSurface();
            } else if (viewMode === 'learning_curve') {
                plotLearningCurve();
            } else if (viewMode === 'complexity_curve') {
                plotComplexityCurve();
            } else {
                plotHeatmap();
            }
        }

        function plot3DSurface() {
            const data = generate3DSurfaceData();

            const trace1 = {
                x: data.trainSizes,
                y: data.complexities,
                z: data.trainErrorSurface,
                type: 'surface',
                name: 'è®­ç»ƒè¯¯å·®',
                colorscale: 'Blues',
                showscale: true,
                opacity: 0.9
            };

            const trace2 = {
                x: data.trainSizes,
                y: data.complexities,
                z: data.valErrorSurface,
                type: 'surface',
                name: 'éªŒè¯è¯¯å·®',
                colorscale: 'Reds',
                showscale: false,
                opacity: 0.7
            };

            const layout = {
                title: 'å­¦ä¹ æ›²çº¿3Dæ›²é¢ï¼ˆè“è‰²=è®­ç»ƒè¯¯å·®ï¼Œçº¢è‰²=éªŒè¯è¯¯å·®ï¼‰',
                scene: {
                    xaxis: { title: 'è®­ç»ƒé›†å¤§å°' },
                    yaxis: { title: 'æ¨¡å‹å¤æ‚åº¦ï¼ˆå¤šé¡¹å¼é˜¶æ•°ï¼‰' },
                    zaxis: { title: 'MSE' }
                },
                height: 700
            };

            Plotly.newPlot('mainChart', [trace1, trace2], build3DLayout(layout));

            document.getElementById('recommendation').innerHTML =
                '<strong>ğŸ’¡ å»ºè®®ï¼š</strong>è§‚å¯Ÿçº¢è‰²æ›²é¢ï¼ˆéªŒè¯è¯¯å·®ï¼‰çš„æœ€ä½ç‚¹åŒºåŸŸï¼Œ' +
                'è¿™æ˜¯æœ€ä¼˜çš„è®­ç»ƒé›†å¤§å°å’Œæ¨¡å‹å¤æ‚åº¦ç»„åˆã€‚';
        }

        function plotLearningCurve() {
            const complexity = 5;
            const data = generateLearningCurveData(complexity);

            const trace1 = {
                x: data.trainSizes,
                y: data.trainErrors,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'è®­ç»ƒè¯¯å·®',
                line: { color: '#1d4ed8', width: 3 },
                marker: { size: 8 }
            };

            const trace2 = {
                x: data.trainSizes,
                y: data.valErrors,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'éªŒè¯è¯¯å·®',
                line: { color: '#f44336', width: 3 },
                marker: { size: 8 }
            };

            const layout = {
                title: `å­¦ä¹ æ›²çº¿ï¼ˆæ¨¡å‹å¤æ‚åº¦=${complexity}ï¼‰`,
                xaxis: { title: 'è®­ç»ƒé›†å¤§å°' },
                yaxis: { title: 'MSE' },
                height: 500
            };

            Plotly.newPlot('mainChart', [trace1, trace2], build2DLayout(layout));

            // åˆ¤æ–­æ˜¯å¦éœ€è¦æ›´å¤šæ•°æ®
            const lastTrainError = data.trainErrors[data.trainErrors.length - 1];
            const lastValError = data.valErrors[data.valErrors.length - 1];
            const gap = lastValError - lastTrainError;

            let recommendation = '';
            if (gap > 0.15) {
                recommendation = '<strong>âš ï¸ å»ºè®®ï¼š</strong>éªŒè¯è¯¯å·®æ˜æ˜¾é«˜äºè®­ç»ƒè¯¯å·®ï¼Œ' +
                    'æ¨¡å‹å­˜åœ¨é«˜æ–¹å·®é—®é¢˜ã€‚<strong>å»ºè®®å¢åŠ è®­ç»ƒæ•°æ®</strong>æˆ–é™ä½æ¨¡å‹å¤æ‚åº¦ã€‚';
            } else if (lastValError > 0.3) {
                recommendation = '<strong>âš ï¸ å»ºè®®ï¼š</strong>è®­ç»ƒå’ŒéªŒè¯è¯¯å·®éƒ½è¾ƒé«˜ï¼Œ' +
                    'æ¨¡å‹å­˜åœ¨é«˜åå·®é—®é¢˜ã€‚<strong>å»ºè®®å¢åŠ æ¨¡å‹å¤æ‚åº¦</strong>æˆ–æ·»åŠ æ›´å¤šç‰¹å¾ã€‚';
            } else {
                recommendation = '<strong>âœ… å»ºè®®ï¼š</strong>æ¨¡å‹è¡¨ç°è‰¯å¥½ï¼Œ' +
                    'è®­ç»ƒå’ŒéªŒè¯è¯¯å·®éƒ½è¾ƒä½ä¸”æ¥è¿‘ã€‚å½“å‰æ•°æ®é‡å’Œæ¨¡å‹å¤æ‚åº¦è¾ƒä¸ºåˆé€‚ã€‚';
            }

            document.getElementById('recommendation').innerHTML = recommendation;
        }

        function plotComplexityCurve() {
            const nSamples = 150;
            const complexities = Array.from({ length: 15 }, (_, i) => i + 1);
            const trainErrors = [];
            const valErrors = [];

            for (let c of complexities) {
                const data = generateLearningCurveData(c, nSamples);
                const idx = data.trainSizes.indexOf(nSamples);
                trainErrors.push(data.trainErrors[idx]);
                valErrors.push(data.valErrors[idx]);
            }

            const trace1 = {
                x: complexities,
                y: trainErrors,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'è®­ç»ƒè¯¯å·®',
                line: { color: '#1d4ed8', width: 3 },
                marker: { size: 8 }
            };

            const trace2 = {
                x: complexities,
                y: valErrors,
                mode: 'lines+markers',
                type: 'scatter',
                name: 'éªŒè¯è¯¯å·®',
                line: { color: '#f44336', width: 3 },
                marker: { size: 8 }
            };

            const layout = {
                title: `æ¨¡å‹å¤æ‚åº¦æ›²çº¿ï¼ˆè®­ç»ƒé›†å¤§å°=${nSamples}ï¼‰`,
                xaxis: { title: 'æ¨¡å‹å¤æ‚åº¦ï¼ˆå¤šé¡¹å¼é˜¶æ•°ï¼‰' },
                yaxis: { title: 'MSE' },
                height: 500
            };

            Plotly.newPlot('mainChart', [trace1, trace2], build2DLayout(layout));

            // æ‰¾åˆ°æœ€ä¼˜å¤æ‚åº¦
            const minValErrorIdx = valErrors.indexOf(Math.min(...valErrors));
            const optimalComplexity = complexities[minValErrorIdx];

            document.getElementById('recommendation').innerHTML =
                `<strong>ğŸ’¡ å»ºè®®ï¼š</strong>åœ¨å½“å‰è®­ç»ƒé›†å¤§å°ï¼ˆ${nSamples}æ ·æœ¬ï¼‰ä¸‹ï¼Œ` +
                `æœ€ä¼˜æ¨¡å‹å¤æ‚åº¦çº¦ä¸º <strong>${optimalComplexity}</strong>ã€‚` +
                `æ­¤æ—¶éªŒè¯è¯¯å·®æœ€ä½ï¼ˆ${valErrors[minValErrorIdx].toFixed(3)}ï¼‰ã€‚`;
        }

        function plotHeatmap() {
            const data = generate3DSurfaceData();

            // è®¡ç®—è¯¯å·®å·®è·ï¼ˆè¿‡æ‹Ÿåˆç¨‹åº¦ï¼‰
            const gapMatrix = [];
            for (let i = 0; i < data.complexities.length; i++) {
                const row = [];
                for (let j = 0; j < data.trainSizes.length; j++) {
                    const gap = data.valErrorSurface[i][j] - data.trainErrorSurface[i][j];
                    row.push(gap);
                }
                gapMatrix.push(row);
            }

            const trace = {
                x: data.trainSizes,
                y: data.complexities,
                z: gapMatrix,
                type: 'heatmap',
                colorscale: 'RdYlGn_r',
                colorbar: { title: 'è¿‡æ‹Ÿåˆç¨‹åº¦<br>(éªŒè¯è¯¯å·®-è®­ç»ƒè¯¯å·®)' }
            };

            const layout = {
                title: 'è¿‡æ‹Ÿåˆçƒ­åŠ›å›¾ï¼ˆé¢œè‰²è¶Šæ·±=è¿‡æ‹Ÿåˆè¶Šä¸¥é‡ï¼‰',
                xaxis: { title: 'è®­ç»ƒé›†å¤§å°' },
                yaxis: { title: 'æ¨¡å‹å¤æ‚åº¦' },
                height: 600
            };

            Plotly.newPlot('mainChart', [trace], build2DLayout(layout));

            document.getElementById('recommendation').innerHTML =
                '<strong>ğŸ’¡ å»ºè®®ï¼š</strong>ç»¿è‰²åŒºåŸŸè¡¨ç¤ºæ¨¡å‹æ³›åŒ–è‰¯å¥½ï¼Œ' +
                'çº¢è‰²åŒºåŸŸè¡¨ç¤ºè¿‡æ‹Ÿåˆä¸¥é‡ã€‚é€‰æ‹©ç»¿è‰²åŒºåŸŸçš„å‚æ•°ç»„åˆã€‚';
        }

        // åˆå§‹åŒ–
        updateVisualization();
    </script>

<script>
(function () {
  const sendHeight = () => {
    if (window.parent === window) return;
    const body = document.body;
    const root = document.documentElement;
    const height = Math.max(
      body ? body.scrollHeight : 0,
      body ? body.offsetHeight : 0,
      root ? root.scrollHeight : 0,
      root ? root.offsetHeight : 0
    );
    window.parent.postMessage({ type: 'iframe-height', height }, '*');
  };

  window.addEventListener('load', sendHeight);
  window.addEventListener('resize', sendHeight);

  if ('ResizeObserver' in window) {
    const observer = new ResizeObserver(sendHeight);
    if (document.body) observer.observe(document.body);
    if (document.documentElement) observer.observe(document.documentElement);
  }

  requestAnimationFrame(sendHeight);
  setTimeout(sendHeight, 250);
  setTimeout(sendHeight, 1000);
})();
</script>
</body>
</html>