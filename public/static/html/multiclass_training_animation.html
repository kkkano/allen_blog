<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>多分类训练过程动画</title>
<style>
  :root {
    --bg: #0f172a;
    --text: #e2e8f0;
    --primary: #3b82f6;
    --accent: #10b981;
    --frozen: #64748b;
    --trainable: #ef4444;
    --lora: #8b5cf6;
    --warning: #f59e0b;
    --card-bg: rgba(30, 41, 59, 0.7);
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 0;
    overflow-x: hidden;
    line-height: 1.6;
  }
  .container { max-width: 960px; margin: 0 auto; padding: 24px 16px; }
  h1 {
    text-align: center; font-size: 1.6rem; font-weight: 700; margin-bottom: 4px;
    background: linear-gradient(135deg, var(--lora), var(--primary));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
  }
  .subtitle { text-align: center; font-size: 0.85rem; color: #94a3b8; margin-bottom: 24px; }

  .section {
    background: var(--card-bg); border-radius: 14px; padding: 20px;
    margin-bottom: 20px; border: 1px solid rgba(100, 116, 139, 0.2);
    backdrop-filter: blur(10px); position: relative; overflow: hidden;
  }
  .section::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px;
    background: linear-gradient(90deg, var(--lora), var(--primary), var(--accent));
  }
  .section-title {
    font-size: 1.05rem; font-weight: 600; margin-bottom: 16px; color: var(--primary);
    display: flex; align-items: center; gap: 8px;
  }
  .section-title::before { content: ''; width: 4px; height: 18px; background: var(--lora); border-radius: 2px; }

  /* Controls */
  .controls-row {
    display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-bottom: 16px;
  }
  .ctrl-btn {
    padding: 8px 24px; border-radius: 10px; font-size: 0.82rem; font-weight: 600;
    border: 1px solid rgba(100,116,139,0.3); background: rgba(15, 23, 42, 0.6);
    color: #94a3b8; cursor: pointer; transition: all 0.3s; display: flex; align-items: center; gap: 6px;
  }
  .ctrl-btn:hover { border-color: var(--primary); color: var(--primary); transform: translateY(-1px); }
  .ctrl-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(16,185,129,0.15); }
  .ctrl-btn.start { border-color: var(--accent); color: var(--accent); }
  .ctrl-btn.start:hover { background: rgba(16,185,129,0.15); }
  .ctrl-btn.pause { border-color: var(--warning); color: var(--warning); }
  .ctrl-btn.pause:hover { background: rgba(245,158,11,0.15); }
  .ctrl-btn.reset { border-color: var(--trainable); color: var(--trainable); }
  .ctrl-btn.reset:hover { background: rgba(239,68,68,0.15); }

  .ctrl-select {
    padding: 8px 14px; border-radius: 10px; font-size: 0.82rem; font-weight: 600;
    border: 1px solid rgba(100,116,139,0.3); background: rgba(15, 23, 42, 0.8);
    color: var(--text); cursor: pointer; outline: none;
  }
  .ctrl-select:focus { border-color: var(--primary); }
  .ctrl-select option { background: var(--bg); color: var(--text); }

  /* Stats Grid */
  .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-bottom: 16px; }
  .stat-card {
    background: rgba(15, 23, 42, 0.6); border-radius: 10px; padding: 14px;
    border: 1px solid rgba(100,116,139,0.2); text-align: center;
    transition: border-color 0.3s, transform 0.3s;
  }
  .stat-card:hover { border-color: var(--primary); transform: translateY(-2px); }
  .stat-label { font-size: 0.68rem; color: #94a3b8; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
  .stat-value { font-size: 1.3rem; font-weight: 700; }
  .stat-value.primary-c { color: var(--primary); }
  .stat-value.accent-c { color: var(--accent); }
  .stat-value.lora-c { color: var(--lora); }
  .stat-value.warning-c { color: var(--warning); }

  /* Canvas */
  .canvas-wrapper { position: relative; width: 100%; }
  canvas { display: block; width: 100%; border-radius: 8px; }
  .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }

  /* Progress bar */
  .progress-bar-wrap {
    height: 6px; background: rgba(100,116,139,0.2); border-radius: 3px; margin-bottom: 16px; overflow: hidden;
  }
  .progress-bar-fill {
    height: 100%; border-radius: 3px; transition: width 0.3s ease;
    background: linear-gradient(90deg, var(--lora), var(--primary), var(--accent));
  }

  /* Insight Cards */
  .insight-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
  .insight-card {
    background: rgba(15, 23, 42, 0.5); border-radius: 10px; padding: 16px;
    border: 1px solid rgba(59, 130, 246, 0.15);
    backdrop-filter: blur(8px); transition: border-color 0.3s, transform 0.3s;
  }
  .insight-card:hover { border-color: var(--primary); transform: translateY(-2px); }
  .insight-card h4 { font-size: 0.88rem; color: var(--primary); margin-bottom: 6px; }
  .insight-card p { font-size: 0.78rem; color: #cbd5e1; line-height: 1.55; }

  /* Legend */
  .legend { display: flex; gap: 16px; justify-content: center; flex-wrap: wrap; margin: 8px 0; }
  .legend-item { display: flex; align-items: center; gap: 5px; font-size: 0.75rem; color: #94a3b8; }
  .legend-dot { width: 10px; height: 10px; border-radius: 3px; }

  @media (max-width: 700px) {
    h1 { font-size: 1.3rem; }
    .stats-grid { grid-template-columns: repeat(2, 1fr); }
    .charts-row { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="container">
  <h1>多分类神经网络训练过程</h1>
  <p class="subtitle">实时观察损失下降、准确率提升和混淆矩阵的演变</p>

  <!-- Controls -->
  <div class="section">
    <div class="section-title">训练控制面板</div>
    <div class="controls-row">
      <button class="ctrl-btn start" id="btn-start">
        <span id="start-icon">&#9654;</span> 开始训练
      </button>
      <button class="ctrl-btn pause" id="btn-pause">
        &#10074;&#10074; 暂停
      </button>
      <button class="ctrl-btn reset" id="btn-reset">
        &#8635; 重置
      </button>
      <select class="ctrl-select" id="sel-lr">
        <option value="0.0001">学习率: 0.0001</option>
        <option value="0.001" selected>学习率: 0.001</option>
        <option value="0.01">学习率: 0.01</option>
        <option value="0.1">学习率: 0.1</option>
      </select>
      <select class="ctrl-select" id="sel-speed">
        <option value="800">速度: 慢</option>
        <option value="400" selected>速度: 正常</option>
        <option value="150">速度: 快</option>
      </select>
    </div>
    <div class="progress-bar-wrap">
      <div class="progress-bar-fill" id="progress-fill" style="width:0%"></div>
    </div>
  </div>

  <!-- Stats -->
  <div class="stats-grid">
    <div class="stat-card">
      <div class="stat-label">当前 Epoch</div>
      <div class="stat-value primary-c" id="stat-epoch">0 / 50</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">训练损失</div>
      <div class="stat-value lora-c" id="stat-loss">--</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">训练准确率</div>
      <div class="stat-value accent-c" id="stat-train-acc">--</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">验证准确率</div>
      <div class="stat-value warning-c" id="stat-val-acc">--</div>
    </div>
  </div>

  <!-- Loss & Accuracy Charts -->
  <div class="section">
    <div class="section-title">训练曲线</div>
    <div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background:var(--primary)"></div>训练损失</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--accent)"></div>训练准确率</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--warning)"></div>验证准确率</div>
    </div>
    <div class="charts-row">
      <div class="canvas-wrapper">
        <canvas id="loss-canvas" height="280"></canvas>
      </div>
      <div class="canvas-wrapper">
        <canvas id="acc-canvas" height="280"></canvas>
      </div>
    </div>
  </div>

  <!-- Confusion Matrix -->
  <div class="section">
    <div class="section-title">混淆矩阵</div>
    <div class="canvas-wrapper">
      <canvas id="conf-canvas" height="420"></canvas>
    </div>
  </div>

  <!-- Per-Class Accuracy -->
  <div class="section">
    <div class="section-title">各类别准确率</div>
    <div class="canvas-wrapper">
      <canvas id="class-acc-canvas" height="260"></canvas>
    </div>
  </div>

  <!-- Insights -->
  <div class="section">
    <div class="section-title">观察要点</div>
    <div class="insight-grid">
      <div class="insight-card">
        <h4>损失曲线</h4>
        <p>交叉熵损失应平稳下降。如果震荡剧烈说明学习率过大，可尝试降低学习率观察差异。</p>
      </div>
      <div class="insight-card">
        <h4>过拟合信号</h4>
        <p>当训练准确率远高于验证准确率时，表明模型正在记忆训练数据而非学习泛化特征。</p>
      </div>
      <div class="insight-card">
        <h4>混淆矩阵解读</h4>
        <p>对角线越亮表示分类越准确。非对角线的亮点揭示易混淆的类别对，是优化重点。</p>
      </div>
      <div class="insight-card">
        <h4>学习率影响</h4>
        <p>尝试不同学习率：小学习率收敛平稳但慢，大学习率收敛快但可能震荡甚至发散。</p>
      </div>
    </div>
  </div>
</div>

<script>
/* ============ State ============ */
var MAX_EPOCHS = 50;
var NUM_CLASSES = 10;
var CLASS_COLORS = [
  '#3b82f6', '#8b5cf6', '#ec4899', '#ef4444', '#f97316',
  '#eab308', '#84cc16', '#10b981', '#06b6d4', '#64748b'
];

var state = {
  epoch: 0,
  running: false,
  timer: null,
  lossHistory: [],
  trainAccHistory: [],
  valAccHistory: [],
  confusionMatrix: createZeroMatrix(NUM_CLASSES),
  classAccuracies: new Array(NUM_CLASSES).fill(0)
};

function createZeroMatrix(n) {
  var m = [];
  for (var i = 0; i < n; i++) {
    m.push(new Array(n).fill(0));
  }
  return m;
}

/* ============ Simulation ============ */
function simulateEpoch(lr) {
  state.epoch++;
  var e = state.epoch;

  // Loss: exponential decay with noise modulated by learning rate
  var baseLoss = 2.3 * Math.exp(-e * lr * 0.5);
  var noise = (Math.random() - 0.5) * 0.08 * Math.min(lr * 10, 1);
  var loss = Math.max(0.03, baseLoss + noise);

  // Accuracy: sigmoid-like growth
  var trainAcc = Math.min(0.995, 0.08 + 0.915 * (1 - Math.exp(-e * lr * 0.3)));
  var trainNoise = (Math.random() - 0.5) * 0.01;
  trainAcc = Math.min(0.999, Math.max(0.05, trainAcc + trainNoise));

  // Validation: slightly lower, with growing gap for overfitting simulation
  var overfit = Math.max(0, (e - 30) * 0.002 * Math.min(lr * 5, 1));
  var valAcc = Math.min(0.97, trainAcc - 0.03 - overfit + (Math.random() - 0.5) * 0.015);
  valAcc = Math.max(0.05, valAcc);

  state.lossHistory.push(loss);
  state.trainAccHistory.push(trainAcc);
  state.valAccHistory.push(valAcc);

  // Confusion matrix simulation
  for (var i = 0; i < NUM_CLASSES; i++) {
    for (var j = 0; j < NUM_CLASSES; j++) {
      if (i === j) {
        state.confusionMatrix[i][j] = Math.floor(50 * trainAcc + Math.random() * 8);
      } else {
        // Some class pairs are more easily confused
        var confuseFactor = 1;
        if ((i === 4 && j === 9) || (i === 9 && j === 4)) confuseFactor = 3;
        if ((i === 3 && j === 8) || (i === 8 && j === 3)) confuseFactor = 2.5;
        if ((i === 5 && j === 6) || (i === 6 && j === 5)) confuseFactor = 2;
        state.confusionMatrix[i][j] = Math.floor(confuseFactor * 4 * (1 - trainAcc) + Math.random() * 2);
      }
    }
  }

  // Per-class accuracy
  for (var i = 0; i < NUM_CLASSES; i++) {
    var rowSum = 0;
    for (var j = 0; j < NUM_CLASSES; j++) rowSum += state.confusionMatrix[i][j];
    state.classAccuracies[i] = rowSum > 0 ? state.confusionMatrix[i][i] / rowSum : 0;
  }

  return { loss: loss, trainAcc: trainAcc, valAcc: valAcc };
}

/* ============ Drawing Helpers ============ */
function setupCanvas(canvasId, desiredHeight) {
  var canvas = document.getElementById(canvasId);
  var dpr = window.devicePixelRatio || 1;
  var rect = canvas.parentElement.getBoundingClientRect();
  var w = rect.width;
  var h = desiredHeight || 280;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  var ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  ctx.clearRect(0, 0, w, h);
  return { ctx: ctx, w: w, h: h };
}

function drawLineChart(canvasId, datasets, yRange, yLabel, height) {
  var c = setupCanvas(canvasId, height || 280);
  var ctx = c.ctx, w = c.w, h = c.h;
  var pad = { left: 55, right: 20, top: 20, bottom: 36 };
  var cw = w - pad.left - pad.right;
  var ch = h - pad.top - pad.bottom;
  var epochs = state.lossHistory.length;
  if (epochs === 0) return;

  // Gridlines
  ctx.strokeStyle = 'rgba(100,116,139,0.12)';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#64748b';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  var steps = 5;
  for (var i = 0; i <= steps; i++) {
    var yVal = yRange[0] + (yRange[1] - yRange[0]) * (i / steps);
    var yPos = pad.top + ch - (i / steps) * ch;
    ctx.beginPath();
    ctx.moveTo(pad.left, yPos);
    ctx.lineTo(pad.left + cw, yPos);
    ctx.stroke();
    ctx.fillText(yVal.toFixed(2), pad.left - 6, yPos);
  }

  // X axis labels
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  var xSteps = Math.min(epochs, 10);
  for (var i = 0; i <= xSteps; i++) {
    var ep = Math.round(i * (epochs - 1) / xSteps) + 1;
    var xPos = pad.left + ((ep - 1) / Math.max(MAX_EPOCHS - 1, 1)) * cw;
    ctx.fillText(ep, xPos, pad.top + ch + 6);
  }
  ctx.fillText('Epoch', pad.left + cw / 2, pad.top + ch + 20);

  // Y axis label
  ctx.save();
  ctx.fillStyle = '#94a3b8';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'center';
  ctx.translate(14, pad.top + ch / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // Draw lines
  for (var d = 0; d < datasets.length; d++) {
    var data = datasets[d].data;
    var color = datasets[d].color;
    var dash = datasets[d].dash || [];

    // Area fill
    ctx.beginPath();
    for (var i = 0; i < data.length; i++) {
      var xPos = pad.left + (i / Math.max(MAX_EPOCHS - 1, 1)) * cw;
      var yNorm = (data[i] - yRange[0]) / (yRange[1] - yRange[0]);
      var yPos = pad.top + ch - yNorm * ch;
      if (i === 0) ctx.moveTo(xPos, yPos);
      else ctx.lineTo(xPos, yPos);
    }
    var lastX = pad.left + ((data.length - 1) / Math.max(MAX_EPOCHS - 1, 1)) * cw;
    ctx.lineTo(lastX, pad.top + ch);
    ctx.lineTo(pad.left, pad.top + ch);
    ctx.closePath();
    ctx.fillStyle = color + '15';
    ctx.fill();

    // Line
    ctx.beginPath();
    ctx.setLineDash(dash);
    for (var i = 0; i < data.length; i++) {
      var xPos = pad.left + (i / Math.max(MAX_EPOCHS - 1, 1)) * cw;
      var yNorm = (data[i] - yRange[0]) / (yRange[1] - yRange[0]);
      var yPos = pad.top + ch - yNorm * ch;
      if (i === 0) ctx.moveTo(xPos, yPos);
      else ctx.lineTo(xPos, yPos);
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    ctx.stroke();
    ctx.setLineDash([]);

    // Last point dot with glow
    if (data.length > 0) {
      var lastVal = data[data.length - 1];
      var lx = pad.left + ((data.length - 1) / Math.max(MAX_EPOCHS - 1, 1)) * cw;
      var ly = pad.top + ch - ((lastVal - yRange[0]) / (yRange[1] - yRange[0])) * ch;
      ctx.beginPath();
      ctx.arc(lx, ly, 4, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.shadowColor = color;
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }
}

/* ============ Confusion Matrix ============ */
function drawConfusionMatrix() {
  var c = setupCanvas('conf-canvas', 420);
  var ctx = c.ctx, w = c.w, h = c.h;
  var pad = { left: 60, right: 40, top: 30, bottom: 50 };
  var gridW = w - pad.left - pad.right;
  var gridH = h - pad.top - pad.bottom;
  var cellW = gridW / NUM_CLASSES;
  var cellH = gridH / NUM_CLASSES;

  // Find max value for normalization
  var maxVal = 1;
  for (var i = 0; i < NUM_CLASSES; i++) {
    for (var j = 0; j < NUM_CLASSES; j++) {
      if (state.confusionMatrix[i][j] > maxVal) maxVal = state.confusionMatrix[i][j];
    }
  }

  // Draw cells
  for (var i = 0; i < NUM_CLASSES; i++) {
    for (var j = 0; j < NUM_CLASSES; j++) {
      var val = state.confusionMatrix[i][j];
      var norm = val / maxVal;
      var x = pad.left + j * cellW;
      var y = pad.top + i * cellH;

      // Color: diagonal = green shades, off-diagonal = purple/red shades
      var r, g, b;
      if (i === j) {
        r = Math.floor(16 + norm * 30);
        g = Math.floor(40 + norm * 145);
        b = Math.floor(60 + norm * 69);
      } else {
        r = Math.floor(30 + norm * 109);
        g = Math.floor(20 + norm * 52);
        b = Math.floor(50 + norm * 196);
      }

      ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
      ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);

      // Value text
      if (val > 0) {
        ctx.fillStyle = norm > 0.5 ? '#fff' : '#94a3b8';
        ctx.font = (cellW > 40 ? 'bold 12px' : 'bold 10px') + ' system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(val, x + cellW / 2, y + cellH / 2);
      }
    }
  }

  // Axis labels
  ctx.fillStyle = '#94a3b8';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for (var j = 0; j < NUM_CLASSES; j++) {
    ctx.fillText(j, pad.left + j * cellW + cellW / 2, pad.top + gridH + 8);
  }
  ctx.fillText('预测类别', pad.left + gridW / 2, pad.top + gridH + 28);

  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (var i = 0; i < NUM_CLASSES; i++) {
    ctx.fillText(i, pad.left - 10, pad.top + i * cellH + cellH / 2);
  }

  ctx.save();
  ctx.translate(14, pad.top + gridH / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.textAlign = 'center';
  ctx.fillText('真实类别', 0, 0);
  ctx.restore();

  // Epoch indicator
  ctx.fillStyle = '#64748b';
  ctx.font = '11px system-ui';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';
  ctx.fillText('Epoch ' + state.epoch, w - pad.right, 8);
}

/* ============ Per-Class Accuracy Bar Chart ============ */
function drawClassAccuracy() {
  var c = setupCanvas('class-acc-canvas', 260);
  var ctx = c.ctx, w = c.w, h = c.h;
  var pad = { left: 50, right: 20, top: 15, bottom: 40 };
  var chartW = w - pad.left - pad.right;
  var chartH = h - pad.top - pad.bottom;
  var barGap = 10;
  var barWidth = (chartW - barGap * (NUM_CLASSES + 1)) / NUM_CLASSES;

  // Gridlines
  ctx.strokeStyle = 'rgba(100,116,139,0.12)';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#64748b';
  ctx.font = '10px system-ui';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (var i = 0; i <= 5; i++) {
    var yVal = i * 0.2;
    var yPos = pad.top + chartH - yVal * chartH;
    ctx.beginPath();
    ctx.moveTo(pad.left, yPos);
    ctx.lineTo(pad.left + chartW, yPos);
    ctx.stroke();
    ctx.fillText((yVal * 100).toFixed(0) + '%', pad.left - 6, yPos);
  }

  // Bars
  for (var i = 0; i < NUM_CLASSES; i++) {
    var acc = state.classAccuracies[i];
    var x = pad.left + barGap + i * (barWidth + barGap);
    var barH = acc * chartH;
    var y = pad.top + chartH - barH;

    var grad = ctx.createLinearGradient(x, y, x, pad.top + chartH);
    grad.addColorStop(0, CLASS_COLORS[i]);
    grad.addColorStop(1, CLASS_COLORS[i] + '33');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(x, y, barWidth, barH, [4, 4, 0, 0]);
    ctx.fill();

    // Value
    if (acc > 0) {
      ctx.fillStyle = CLASS_COLORS[i];
      ctx.font = 'bold 9px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText((acc * 100).toFixed(0) + '%', x + barWidth / 2, y - 3);
    }

    // Class label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textBaseline = 'top';
    ctx.textAlign = 'center';
    ctx.fillText('C' + i, x + barWidth / 2, pad.top + chartH + 6);
  }
}

/* ============ Update All ============ */
function updateDisplay(metrics) {
  document.getElementById('stat-epoch').textContent = state.epoch + ' / ' + MAX_EPOCHS;
  document.getElementById('progress-fill').style.width = (state.epoch / MAX_EPOCHS * 100) + '%';

  if (metrics) {
    document.getElementById('stat-loss').textContent = metrics.loss.toFixed(4);
    document.getElementById('stat-train-acc').textContent = (metrics.trainAcc * 100).toFixed(1) + '%';
    document.getElementById('stat-val-acc').textContent = (metrics.valAcc * 100).toFixed(1) + '%';
  }

  drawLineChart('loss-canvas', [
    { data: state.lossHistory, color: '#3b82f6' }
  ], [0, 2.5], 'Loss', 280);

  drawLineChart('acc-canvas', [
    { data: state.trainAccHistory, color: '#10b981' },
    { data: state.valAccHistory, color: '#f59e0b', dash: [6, 4] }
  ], [0, 1.0], 'Accuracy', 280);

  drawConfusionMatrix();
  drawClassAccuracy();
}

/* ============ Training Controls ============ */
function startTraining() {
  if (state.running) return;
  if (state.epoch >= MAX_EPOCHS) return;
  state.running = true;

  var lr = parseFloat(document.getElementById('sel-lr').value);
  var speed = parseInt(document.getElementById('sel-speed').value);

  function tick() {
    if (!state.running || state.epoch >= MAX_EPOCHS) {
      state.running = false;
      return;
    }
    var metrics = simulateEpoch(lr);
    updateDisplay(metrics);
    state.timer = setTimeout(tick, speed);
  }
  tick();
}

function pauseTraining() {
  state.running = false;
  if (state.timer) { clearTimeout(state.timer); state.timer = null; }
}

function resetTraining() {
  pauseTraining();
  state.epoch = 0;
  state.lossHistory = [];
  state.trainAccHistory = [];
  state.valAccHistory = [];
  state.confusionMatrix = createZeroMatrix(NUM_CLASSES);
  state.classAccuracies = new Array(NUM_CLASSES).fill(0);

  document.getElementById('stat-epoch').textContent = '0 / ' + MAX_EPOCHS;
  document.getElementById('stat-loss').textContent = '--';
  document.getElementById('stat-train-acc').textContent = '--';
  document.getElementById('stat-val-acc').textContent = '--';
  document.getElementById('progress-fill').style.width = '0%';

  // Clear all canvases
  ['loss-canvas', 'acc-canvas', 'conf-canvas', 'class-acc-canvas'].forEach(function(id) {
    var canvas = document.getElementById(id);
    var ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  });
}

/* ============ Event Listeners ============ */
document.getElementById('btn-start').addEventListener('click', startTraining);
document.getElementById('btn-pause').addEventListener('click', pauseTraining);
document.getElementById('btn-reset').addEventListener('click', resetTraining);

// Changing LR or speed during training should restart with new values
document.getElementById('sel-lr').addEventListener('change', function() {
  if (state.running) {
    pauseTraining();
    startTraining();
  }
});
document.getElementById('sel-speed').addEventListener('change', function() {
  if (state.running) {
    pauseTraining();
    startTraining();
  }
});

window.addEventListener('resize', function() {
  if (state.epoch > 0) {
    updateDisplay(null);
  }
});
</script>

<script>
(function () {
  const sendHeight = () => {
    if (window.parent === window) return;
    const body = document.body;
    const root = document.documentElement;
    const height = Math.max(
      body ? body.scrollHeight : 0,
      body ? body.offsetHeight : 0,
      root ? root.scrollHeight : 0,
      root ? root.offsetHeight : 0
    );
    window.parent.postMessage({ type: 'iframe-height', height }, '*');
  };
  window.addEventListener('load', sendHeight);
  window.addEventListener('resize', sendHeight);
  if ('ResizeObserver' in window) {
    const observer = new ResizeObserver(sendHeight);
    if (document.body) observer.observe(document.body);
    if (document.documentElement) observer.observe(document.documentElement);
  }
  requestAnimationFrame(sendHeight);
  setTimeout(sendHeight, 250);
  setTimeout(sendHeight, 1000);
})();
</script>
</body>
</html>
