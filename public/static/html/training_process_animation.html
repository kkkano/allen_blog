<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>è®­ç»ƒè¿‡ç¨‹åŠ¨ç”»</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg-a: #e4ecff;
      --bg-b: #f1f5ff;
      --card: #ffffff;
      --border: #dbe5ff;
      --title: #27365f;
      --sub: #6679a8;
      --btn-a: #5f78e5;
      --btn-b: #6d5bc9;
      --ok: #4caf50;
      --warn: #ff9800;
      --danger: #f44336;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 16px;
      min-height: 0;
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
      background: linear-gradient(135deg, var(--bg-a) 0%, var(--bg-b) 100%);
      color: #28395f;
    }

    .wrap {
      max-width: 1020px;
      margin: 0 auto;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 12px 28px rgba(77, 104, 198, 0.15);
      padding: 14px;
      overflow: hidden;
    }

    .head {
      text-align: center;
      margin-bottom: 10px;
    }

    .head h1 {
      margin: 0;
      color: var(--title);
      font-size: 1.8rem;
      letter-spacing: 0.2px;
    }

    .head p {
      margin: 6px 0 0;
      color: var(--sub);
      font-size: 0.92rem;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.1fr 0.9fr;
      gap: 10px;
    }

    .panel {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #fbfdff;
      padding: 10px;
    }

    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .chart-box {
      border: 1px solid #dde6ff;
      border-radius: 10px;
      background: #fff;
      padding: 8px;
      min-height: 228px;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    .chart-box h3 {
      margin: 0 0 4px;
      text-align: center;
      font-size: 0.94rem;
      color: #334a7d;
    }

    .chart-box canvas {
      width: 100%;
      height: 180px !important;
      display: block;
    }

    .controls {
      display: grid;
      gap: 8px;
      align-content: start;
    }

    .controls h3 {
      margin: 0;
      color: #314777;
      font-size: 0.95rem;
    }

    .line {
      display: grid;
      gap: 5px;
    }

    .line label {
      display: flex;
      justify-content: space-between;
      color: #4f6394;
      font-size: 0.8rem;
    }

    .val {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: #314d8b;
      font-weight: 600;
    }

    input[type='range'] {
      width: 100%;
      accent-color: #6785e7;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 2px;
    }

    .stat {
      border: 1px solid #d7e2ff;
      border-radius: 10px;
      background: linear-gradient(135deg, #eef3ff 0%, #e4ecff 100%);
      padding: 8px;
      text-align: center;
    }

    .stat-k {
      color: #586d9f;
      font-size: 0.76rem;
      margin-bottom: 4px;
    }

    .stat-v {
      color: #2e4379;
      font-size: 1.2rem;
      font-weight: 700;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 8px 14px;
      background: linear-gradient(135deg, var(--btn-a), var(--btn-b));
      color: #fff;
      font-size: 0.84rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(82, 109, 204, 0.3);
    }

    button.secondary {
      background: linear-gradient(135deg, #7a8ec0, #6c7ca9);
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .status-box {
      border: 1px solid #d8e2ff;
      border-radius: 10px;
      padding: 8px;
      background: #f6f9ff;
      font-size: 0.82rem;
      line-height: 1.5;
      color: #4b6093;
      min-height: 56px;
    }

    .hint {
      margin-top: 6px;
      border: 1px dashed #cfdbff;
      border-radius: 10px;
      padding: 8px;
      font-size: 0.8rem;
      color: #5a71a3;
      background: #f9fbff;
      line-height: 1.48;
    }

    @media (max-width: 940px) {
      .layout { grid-template-columns: 1fr; }
      .head h1 { font-size: 1.5rem; }
    }

    @media (max-width: 560px) {
      body { padding: 10px; }
      .wrap { padding: 10px; }
      .stats { grid-template-columns: 1fr 1fr; }
      .btn-row button { flex: 1 1 auto; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="head">
      <h1>ğŸ“ˆ è®­ç»ƒè¿‡ç¨‹åŠ¨ç”»</h1>
      <p>åŒæ­¥è§‚å¯Ÿ Loss ä¸‹é™ã€Accuracy ä¸Šå‡ã€å­¦ä¹ ç‡è°ƒåº¦å’Œè¿‡æ‹Ÿåˆé£é™©æç¤º</p>
    </div>

    <div class="layout">
      <div class="panel charts">
        <div class="chart-box">
          <h3>æŸå¤±å‡½æ•°å˜åŒ–ï¼ˆè¶Šä½è¶Šå¥½ï¼‰</h3>
          <canvas id="lossChart"></canvas>
        </div>
        <div class="chart-box">
          <h3>å‡†ç¡®ç‡å˜åŒ–ï¼ˆè¶Šé«˜è¶Šå¥½ï¼‰</h3>
          <canvas id="accuracyChart"></canvas>
        </div>
      </div>

      <div class="panel controls">
        <h3>è®­ç»ƒæ§åˆ¶</h3>

        <div class="line">
          <label>æ€» Epoch <span id="epochsVal" class="val">20</span></label>
          <input id="epochs" type="range" min="10" max="50" step="1" value="20" />
        </div>

        <div class="line">
          <label>å­¦ä¹ ç‡ <span id="lrVal" class="val">0.010</span></label>
          <input id="lr" type="range" min="0.001" max="0.03" step="0.001" value="0.010" />
        </div>

        <div class="line">
          <label>å™ªå£°å¼ºåº¦ <span id="noiseVal" class="val">0.020</span></label>
          <input id="noise" type="range" min="0" max="0.08" step="0.005" value="0.020" />
        </div>

        <div class="line">
          <label>æ’­æ”¾é€Ÿåº¦ <span id="speedVal" class="val">1.00</span></label>
          <input id="speed" type="range" min="0.5" max="2.5" step="0.1" value="1.00" />
        </div>

        <div class="stats">
          <div class="stat"><div class="stat-k">å½“å‰ Epoch</div><div id="statEpoch" class="stat-v">0</div></div>
          <div class="stat"><div class="stat-k">å½“å‰ Loss</div><div id="statLoss" class="stat-v">0.680</div></div>
          <div class="stat"><div class="stat-k">å½“å‰ Accuracy</div><div id="statAcc" class="stat-v">50.0%</div></div>
          <div class="stat"><div class="stat-k">å­¦ä¹ ç‡çŠ¶æ€</div><div id="statLrMode" class="stat-v" style="font-size:1rem">Warmup</div></div>
        </div>

        <div class="btn-row">
          <button id="startBtn">â–¶ å¼€å§‹è®­ç»ƒ</button>
          <button id="pauseBtn">â¸ æš‚åœ</button>
          <button id="stepBtn">â­ å•æ­¥</button>
          <button id="resetBtn" class="secondary">â†º é‡ç½®</button>
        </div>

        <div id="statusBox" class="status-box">
          å‡†å¤‡å°±ç»ªï¼šç‚¹å‡»â€œå¼€å§‹è®­ç»ƒâ€è§‚å¯Ÿæ›²çº¿éš epoch çš„åŠ¨æ€å˜åŒ–ã€‚
        </div>

        <div class="hint">
          <strong>è¯»å›¾æç¤ºï¼š</strong>å¦‚æœ Loss ä¸‹é™å¾ˆæ…¢ä¸”å‡†ç¡®ç‡å¡ä½ï¼Œé€šå¸¸æ˜¯å­¦ä¹ ç‡è¿‡å°ï¼›è‹¥æ›²çº¿å‰§çƒˆæŠ–åŠ¨ï¼Œå¯èƒ½æ˜¯å­¦ä¹ ç‡è¿‡å¤§æˆ–å™ªå£°è¿‡é«˜ã€‚
        </div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const controls = {
        epochs: document.getElementById('epochs'),
        lr: document.getElementById('lr'),
        noise: document.getElementById('noise'),
        speed: document.getElementById('speed'),
      };

      const labels = {
        epochs: document.getElementById('epochsVal'),
        lr: document.getElementById('lrVal'),
        noise: document.getElementById('noiseVal'),
        speed: document.getElementById('speedVal'),
      };

      const stat = {
        epoch: document.getElementById('statEpoch'),
        loss: document.getElementById('statLoss'),
        acc: document.getElementById('statAcc'),
        lrMode: document.getElementById('statLrMode'),
      };

      const statusBox = document.getElementById('statusBox');

      const buttons = {
        start: document.getElementById('startBtn'),
        pause: document.getElementById('pauseBtn'),
        step: document.getElementById('stepBtn'),
        reset: document.getElementById('resetBtn'),
      };

      const palette = {
        loss: '#f44336',
        acc: '#4caf50',
      };

      const state = {
        totalEpochs: Number(controls.epochs.value),
        baseLr: Number(controls.lr.value),
        noise: Number(controls.noise.value),
        speed: Number(controls.speed.value),
        currentEpoch: 0,
        running: false,
        lossHistory: [],
        accHistory: [],
      };

      let timer = null;

      function randomGaussian() {
        const u = Math.max(1e-8, Math.random());
        const v = Math.random();
        return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }

      function syncLabels() {
        labels.epochs.textContent = String(state.totalEpochs);
        labels.lr.textContent = state.baseLr.toFixed(3);
        labels.noise.textContent = state.noise.toFixed(3);
        labels.speed.textContent = state.speed.toFixed(2);
      }

      function effectiveLr(epoch) {
        const warmupEpochs = Math.max(2, Math.floor(state.totalEpochs * 0.15));
        if (epoch <= warmupEpochs) {
          return state.baseLr * (0.4 + (0.6 * epoch) / warmupEpochs);
        }
        const progress = (epoch - warmupEpochs) / Math.max(1, state.totalEpochs - warmupEpochs);
        return state.baseLr * (1 - 0.55 * progress);
      }

      function lrMode(epoch) {
        const warmupEpochs = Math.max(2, Math.floor(state.totalEpochs * 0.15));
        return epoch <= warmupEpochs ? 'Warmup' : 'Decay';
      }

      function simulatePoint(epoch) {
        const lr = effectiveLr(epoch);
        const smoothProgress = epoch / Math.max(1, state.totalEpochs);

        const baseLoss = 0.68 * Math.exp(-3.6 * smoothProgress * (0.6 + lr * 28));
        const noisyLoss = Math.max(0.02, baseLoss + state.noise * 0.6 * randomGaussian());

        const baseAcc = 50 + 48 * (1 - Math.exp(-4.4 * smoothProgress * (0.8 + lr * 22)));
        const noisyAcc = Math.max(45, Math.min(99.5, baseAcc + state.noise * 30 * randomGaussian()));

        return {
          epoch,
          loss: noisyLoss,
          accuracy: noisyAcc,
          lr,
        };
      }

      const lossChart = new Chart(document.getElementById('lossChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Loss',
            data: [],
            borderColor: palette.loss,
            backgroundColor: 'rgba(244, 67, 54, 0.12)',
            pointRadius: 2,
            tension: 0.25,
            fill: true,
          }],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { grid: { color: 'rgba(130,150,210,0.15)' } },
            y: {
              beginAtZero: true,
              suggestedMax: 0.75,
              grid: { color: 'rgba(130,150,210,0.15)' },
            },
          },
        },
      });

      const accChart = new Chart(document.getElementById('accuracyChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Accuracy',
            data: [],
            borderColor: palette.acc,
            backgroundColor: 'rgba(76, 175, 80, 0.12)',
            pointRadius: 2,
            tension: 0.25,
            fill: true,
          }],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { grid: { color: 'rgba(130,150,210,0.15)' } },
            y: {
              beginAtZero: true,
              max: 100,
              grid: { color: 'rgba(130,150,210,0.15)' },
            },
          },
        },
      });

      function updateStats(point) {
        stat.epoch.textContent = String(point.epoch);
        stat.loss.textContent = point.loss.toFixed(3);
        stat.acc.textContent = `${point.accuracy.toFixed(1)}%`;
        stat.lrMode.textContent = lrMode(point.epoch);
      }

      function drawOneStep() {
        if (state.currentEpoch >= state.totalEpochs) {
          stopTraining('è®­ç»ƒå®Œæˆï¼šå·²è¾¾åˆ°è®¾å®šçš„æ€» Epochã€‚');
          return;
        }

        state.currentEpoch += 1;
        const point = simulatePoint(state.currentEpoch);

        state.lossHistory.push(point.loss);
        state.accHistory.push(point.accuracy);

        lossChart.data.labels.push(`E${point.epoch}`);
        lossChart.data.datasets[0].data.push(point.loss);
        lossChart.update();

        accChart.data.labels.push(`E${point.epoch}`);
        accChart.data.datasets[0].data.push(point.accuracy);
        accChart.update();

        updateStats(point);
        statusBox.textContent = `è®­ç»ƒä¸­ï¼šEpoch ${point.epoch}/${state.totalEpochs}ï¼ŒLoss=${point.loss.toFixed(3)}ï¼ŒAccuracy=${point.accuracy.toFixed(1)}%ï¼ŒLR=${point.lr.toFixed(4)}ã€‚`;
        reportHeight();
      }

      function startTraining() {
        if (state.running) return;
        state.running = true;
        statusBox.textContent = 'è®­ç»ƒå¼€å§‹ï¼šæ­£åœ¨å®æ—¶æ›´æ–°æŸå¤±ä¸å‡†ç¡®ç‡æ›²çº¿ã€‚';

        const interval = Math.max(120, 520 / Math.max(0.5, state.speed));
        timer = setInterval(drawOneStep, interval);
      }

      function stopTraining(customMessage) {
        if (timer) {
          clearInterval(timer);
          timer = null;
        }
        state.running = false;
        if (customMessage) {
          statusBox.textContent = customMessage;
        }
      }

      function pauseTraining() {
        if (!state.running) {
          statusBox.textContent = 'å½“å‰æœªåœ¨è®­ç»ƒï¼šå¯ä»¥ç‚¹å‡»â€œå¼€å§‹è®­ç»ƒâ€æˆ–â€œå•æ­¥â€ã€‚';
          return;
        }
        stopTraining('è®­ç»ƒå·²æš‚åœï¼šå¯ç»§ç»­è®­ç»ƒæˆ–å•æ­¥è§‚å¯Ÿã€‚');
      }

      function resetTraining() {
        stopTraining();

        state.currentEpoch = 0;
        state.lossHistory = [];
        state.accHistory = [];

        lossChart.data.labels = [];
        lossChart.data.datasets[0].data = [];
        lossChart.update();

        accChart.data.labels = [];
        accChart.data.datasets[0].data = [];
        accChart.update();

        stat.epoch.textContent = '0';
        stat.loss.textContent = '0.680';
        stat.acc.textContent = '50.0%';
        stat.lrMode.textContent = 'Warmup';
        statusBox.textContent = 'å·²é‡ç½®ï¼šç‚¹å‡»â€œå¼€å§‹è®­ç»ƒâ€è§‚å¯Ÿå®Œæ•´è¿‡ç¨‹ã€‚';
        reportHeight();
      }

      function bind() {
        buttons.start.addEventListener('click', startTraining);
        buttons.pause.addEventListener('click', pauseTraining);
        buttons.step.addEventListener('click', () => {
          if (state.running) {
            pauseTraining();
          }
          drawOneStep();
        });
        buttons.reset.addEventListener('click', resetTraining);

        controls.epochs.addEventListener('input', () => {
          state.totalEpochs = Number(controls.epochs.value);
          syncLabels();
          statusBox.textContent = `å·²è®¾ç½®æ€» Epoch ä¸º ${state.totalEpochs}ã€‚`;
          reportHeight();
        });

        controls.lr.addEventListener('input', () => {
          state.baseLr = Number(controls.lr.value);
          syncLabels();
          reportHeight();
        });

        controls.noise.addEventListener('input', () => {
          state.noise = Number(controls.noise.value);
          syncLabels();
          reportHeight();
        });

        controls.speed.addEventListener('input', () => {
          state.speed = Number(controls.speed.value);
          syncLabels();
          if (state.running) {
            stopTraining('é€Ÿåº¦å·²å˜åŒ–ï¼šè¯·ç‚¹å‡»â€œå¼€å§‹è®­ç»ƒâ€ç»§ç»­ã€‚');
          }
          reportHeight();
        });

        window.addEventListener('resize', reportHeight, { passive: true });
        if ('ResizeObserver' in window) {
          const observer = new ResizeObserver(reportHeight);
          observer.observe(document.body);
          observer.observe(document.documentElement);
        }
      }

      function reportHeight() {
        if (window.parent === window) return;
        const body = document.body;
        const root = document.documentElement;
        const h = Math.max(
          body ? body.scrollHeight : 0,
          body ? body.offsetHeight : 0,
          root ? root.scrollHeight : 0,
          root ? root.offsetHeight : 0
        );
        window.parent.postMessage({ type: 'iframe-height', height: h }, '*');
      }

      function init() {
        syncLabels();
        bind();
        resetTraining();
        setTimeout(reportHeight, 120);
        setTimeout(reportHeight, 480);
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
