<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>参数高效微调方法对比</title>
<style>
  :root {
    --bg: #0f172a;
    --text: #e2e8f0;
    --primary: #3b82f6;
    --accent: #10b981;
    --frozen: #64748b;
    --trainable: #ef4444;
    --lora: #8b5cf6;
  }
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }
  .container {
    max-width: 960px;
    margin: 0 auto;
    padding: 24px 16px;
  }
  h1 {
    text-align: center;
    font-size: 1.6rem;
    font-weight: 700;
    margin-bottom: 6px;
    background: linear-gradient(135deg, var(--primary), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .subtitle {
    text-align: center;
    font-size: 0.85rem;
    color: #94a3b8;
    margin-bottom: 20px;
  }
  .mode-buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .mode-btn {
    padding: 10px 24px;
    border: 2px solid var(--frozen);
    border-radius: 8px;
    background: transparent;
    color: var(--text);
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.35s ease;
    position: relative;
    overflow: hidden;
  }
  .mode-btn::after {
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0;
    transition: opacity 0.35s ease;
    border-radius: 6px;
  }
  .mode-btn:hover { transform: translateY(-1px); }
  .mode-btn[data-mode="full"].active {
    border-color: var(--trainable);
    color: #fff;
    box-shadow: 0 0 20px rgba(239,68,68,0.3);
  }
  .mode-btn[data-mode="full"].active::after {
    opacity: 1;
    background: linear-gradient(135deg, rgba(239,68,68,0.15), transparent);
  }
  .mode-btn[data-mode="adapter"].active {
    border-color: var(--accent);
    color: #fff;
    box-shadow: 0 0 20px rgba(16,185,129,0.3);
  }
  .mode-btn[data-mode="adapter"].active::after {
    opacity: 1;
    background: linear-gradient(135deg, rgba(16,185,129,0.15), transparent);
  }
  .mode-btn[data-mode="lora"].active {
    border-color: var(--lora);
    color: #fff;
    box-shadow: 0 0 20px rgba(139,92,246,0.3);
  }
  .mode-btn[data-mode="lora"].active::after {
    opacity: 1;
    background: linear-gradient(135deg, rgba(139,92,246,0.15), transparent);
  }
  .canvas-wrap {
    position: relative;
    width: 100%;
    border-radius: 12px;
    overflow: hidden;
    background: linear-gradient(180deg, rgba(15,23,42,0.9), rgba(30,41,59,0.6));
    border: 1px solid rgba(100,116,139,0.2);
    margin-bottom: 20px;
  }
  canvas { display: block; width: 100%; height: auto; }
  .info-panel {
    border-radius: 12px;
    padding: 20px;
    background: rgba(30,41,59,0.7);
    border: 1px solid rgba(100,116,139,0.2);
    margin-bottom: 20px;
    transition: opacity 0.4s ease;
  }
  .info-title {
    font-size: 1.15rem;
    font-weight: 700;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .info-title .dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    display: inline-block;
  }
  .info-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }
  .info-card {
    padding: 12px;
    border-radius: 8px;
    background: rgba(15,23,42,0.6);
  }
  .info-card h4 {
    font-size: 0.8rem;
    color: #94a3b8;
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .info-card ul {
    list-style: none;
    font-size: 0.85rem;
    line-height: 1.7;
  }
  .info-card li::before {
    content: '';
    display: inline-block;
    width: 5px; height: 5px;
    border-radius: 50%;
    margin-right: 8px;
    vertical-align: middle;
  }
  .info-card.pros li::before { background: var(--accent); }
  .info-card.cons li::before { background: var(--trainable); }
  .stats-section {
    border-radius: 12px;
    padding: 20px;
    background: rgba(30,41,59,0.7);
    border: 1px solid rgba(100,116,139,0.2);
  }
  .stats-title {
    font-size: 1rem;
    font-weight: 700;
    margin-bottom: 16px;
    text-align: center;
    color: #94a3b8;
  }
  .stat-row {
    display: flex;
    align-items: center;
    margin-bottom: 14px;
  }
  .stat-label {
    width: 100px;
    font-size: 0.8rem;
    color: #94a3b8;
    flex-shrink: 0;
  }
  .stat-bars {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .stat-bar-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .stat-bar-label {
    width: 70px;
    font-size: 0.7rem;
    text-align: right;
    flex-shrink: 0;
  }
  .stat-bar-track {
    flex: 1;
    height: 8px;
    background: rgba(100,116,139,0.2);
    border-radius: 4px;
    overflow: hidden;
  }
  .stat-bar-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.8s cubic-bezier(0.4,0,0.2,1);
    position: relative;
  }
  .stat-bar-fill::after {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15));
    border-radius: 4px;
  }
  .stat-val {
    width: 44px;
    font-size: 0.72rem;
    font-weight: 600;
    flex-shrink: 0;
  }
  .legend {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 14px;
    flex-wrap: wrap;
  }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    color: #94a3b8;
  }
  .legend-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
  }
  @media (max-width: 600px) {
    .info-grid { grid-template-columns: 1fr; }
    .mode-btn { padding: 8px 16px; font-size: 0.85rem; }
    h1 { font-size: 1.2rem; }
  }
</style>
</head>
<body>
<div class="container">
  <h1>参数高效微调方法对比</h1>
  <p class="subtitle">Parameter-Efficient Fine-Tuning: 全量微调 vs Adapter vs LoRA</p>
  <div class="mode-buttons">
    <button class="mode-btn active" data-mode="full" onclick="switchMode('full')">全量微调</button>
    <button class="mode-btn" data-mode="adapter" onclick="switchMode('adapter')">Adapter</button>
    <button class="mode-btn" data-mode="lora" onclick="switchMode('lora')">LoRA</button>
  </div>
  <div class="canvas-wrap">
    <canvas id="netCanvas" width="920" height="420"></canvas>
  </div>
  <div class="info-panel" id="infoPanel"></div>
  <div class="stats-section" id="statsSection"></div>
</div>
<script>
(function() {
  const C = document.getElementById('netCanvas');
  const ctx = C.getContext('2d');
  const W = C.width, H = C.height;

  const COLORS = {
    bg: '#0f172a', frozen: '#64748b', trainable: '#ef4444',
    accent: '#10b981', lora: '#8b5cf6', primary: '#3b82f6', text: '#e2e8f0'
  };

  const LAYERS = [
    { name: '嵌入层', short: 'Embedding' },
    { name: 'Transformer 1', short: 'TF-1' },
    { name: 'Transformer 2', short: 'TF-2' },
    { name: '前馈网络', short: 'FFN' },
    { name: '分类器', short: 'Classifier' }
  ];

  const INFO = {
    full: {
      title: '全量微调',
      color: COLORS.trainable,
      params: '100%',
      pros: ['效果最优，性能上限高', '训练充分，覆盖全部参数', '适合数据充足的场景'],
      cons: ['显存占用极高', '训练速度慢，成本高', '容易过拟合小数据集', '每个任务需独立存储完整模型']
    },
    adapter: {
      title: 'Adapter 微调',
      color: COLORS.accent,
      params: '~3-5%',
      pros: ['参数量极少，显存高效', '原模型参数完全冻结', '多任务仅需切换适配器', '接近全量微调的效果'],
      cons: ['引入额外推理延迟', '瓶颈维度需仔细调参', '在极低资源下可能不稳定']
    },
    lora: {
      title: 'LoRA 低秩适配',
      color: COLORS.lora,
      params: '~0.5-2%',
      pros: ['参数量最少，效率最高', '推理时无额外延迟 (可合并)', '训练速度快，显存极低', '可灵活组合多个 LoRA 模块'],
      cons: ['低秩假设不一定适用所有层', '秩的选择影响效果', '合并后难以回退单个适配']
    }
  };

  const STATS = [
    { label: '可训练参数', key: 'params', full: 100, adapter: 4, lora: 1.5 },
    { label: '显存占用', key: 'memory', full: 95, adapter: 35, lora: 20 },
    { label: '训练速度', key: 'speed', full: 30, adapter: 70, lora: 90 },
    { label: '模型性能', key: 'perf', full: 95, adapter: 88, lora: 90 }
  ];

  let currentMode = 'full';
  let transitionProgress = 1;
  let prevMode = 'full';
  let particles = [];
  let animFrame = 0;

  const layerW = 120, layerH = 56, gap = 40;
  const totalW = LAYERS.length * layerW + (LAYERS.length - 1) * gap;
  const startX = (W - totalW) / 2;
  const layerY = H / 2 - layerH / 2;

  function layerRect(i) {
    return {
      x: startX + i * (layerW + gap),
      y: layerY,
      w: layerW,
      h: layerH
    };
  }

  function initParticles() {
    particles = [];
    for (let i = 0; i < 18; i++) {
      particles.push(createParticle());
    }
  }

  function createParticle() {
    return {
      x: startX - 30 - Math.random() * 80,
      y: layerY + layerH / 2 + (Math.random() - 0.5) * 20,
      speed: 1.2 + Math.random() * 1.5,
      size: 2 + Math.random() * 2.5,
      alpha: 0.5 + Math.random() * 0.5,
      baseY: layerY + layerH / 2
    };
  }

  function easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  function lerpColor(a, b, t) {
    const pa = [parseInt(a.slice(1,3),16), parseInt(a.slice(3,5),16), parseInt(a.slice(5,7),16)];
    const pb = [parseInt(b.slice(1,3),16), parseInt(b.slice(3,5),16), parseInt(b.slice(5,7),16)];
    const r = Math.round(pa[0] + (pb[0]-pa[0]) * t);
    const g = Math.round(pa[1] + (pb[1]-pa[1]) * t);
    const bl = Math.round(pa[2] + (pb[2]-pa[2]) * t);
    return `rgb(${r},${g},${bl})`;
  }

  function getLayerColor(mode, i) {
    if (mode === 'full') return COLORS.trainable;
    return COLORS.frozen;
  }

  function getGlowColor(mode) {
    if (mode === 'full') return COLORS.trainable;
    if (mode === 'adapter') return COLORS.accent;
    return COLORS.lora;
  }

  function drawRoundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }

  function drawLayer(i, t) {
    const r = layerRect(i);
    const prevColor = getLayerColor(prevMode, i);
    const nextColor = getLayerColor(currentMode, i);
    const color = (t >= 1) ? nextColor : lerpColor(prevColor, nextColor, easeInOut(t));

    const glowAlpha = (currentMode === 'full' ? 0.35 : 0.15) * (t >= 1 ? 1 : easeInOut(t));
    ctx.save();
    ctx.shadowColor = color;
    ctx.shadowBlur = currentMode === 'full' ? 18 : 8;

    drawRoundRect(r.x, r.y, r.w, r.h, 10);
    ctx.fillStyle = color + (currentMode === 'full' ? '30' : '18');
    ctx.fill();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 11px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(LAYERS[i].name, r.x + r.w / 2, r.y + r.h / 2 - 7);
    ctx.font = '10px system-ui, sans-serif';
    ctx.fillStyle = '#94a3b8';
    ctx.fillText(LAYERS[i].short, r.x + r.w / 2, r.y + r.h / 2 + 9);
  }

  function drawConnection(i) {
    if (i >= LAYERS.length - 1) return;
    const a = layerRect(i);
    const b = layerRect(i + 1);
    ctx.beginPath();
    ctx.moveTo(a.x + a.w, a.y + a.h / 2);
    ctx.lineTo(b.x, b.y + b.h / 2);
    ctx.strokeStyle = 'rgba(100,116,139,0.25)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  function drawAdapterModule(i, t) {
    if (i >= LAYERS.length - 1) return;
    const a = layerRect(i);
    const b = layerRect(i + 1);
    const cx = (a.x + a.w + b.x) / 2;
    const cy = a.y + a.h / 2;
    const mw = 28, mh = 34;
    const alpha = easeInOut(Math.min(t, 1));

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.shadowColor = COLORS.accent;
    ctx.shadowBlur = 14;

    ctx.beginPath();
    ctx.moveTo(cx - mw / 2, cy - mh / 2);
    ctx.lineTo(cx + mw / 2, cy - mh / 2);
    ctx.lineTo(cx + mw / 4, cy);
    ctx.lineTo(cx + mw / 2, cy + mh / 2);
    ctx.lineTo(cx - mw / 2, cy + mh / 2);
    ctx.lineTo(cx - mw / 4, cy);
    ctx.closePath();
    ctx.fillStyle = COLORS.accent + '35';
    ctx.fill();
    ctx.strokeStyle = COLORS.accent;
    ctx.lineWidth = 1.8;
    ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.fillStyle = COLORS.text;
    ctx.font = 'bold 8px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Adapter', cx, cy);
    ctx.restore();
  }

  function drawLoRABypass(i, t) {
    if (i === 0 || i >= LAYERS.length - 1) return;
    const r = layerRect(i);
    const alpha = easeInOut(Math.min(t, 1));
    const cx = r.x + r.w / 2;
    const topY = r.y - 4;
    const botY = r.y + r.h + 4;
    const curveOff = 50;

    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.shadowColor = COLORS.lora;
    ctx.shadowBlur = 12;

    ctx.beginPath();
    ctx.moveTo(cx - 30, topY);
    ctx.quadraticCurveTo(cx - 30 - curveOff, topY - 28, cx, topY - 38);
    ctx.quadraticCurveTo(cx + 30 + curveOff, topY - 28, cx + 30, topY);
    ctx.strokeStyle = COLORS.lora;
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.beginPath();
    ctx.moveTo(cx - 30, botY);
    ctx.quadraticCurveTo(cx - 30 - curveOff, botY + 28, cx, botY + 38);
    ctx.quadraticCurveTo(cx + 30 + curveOff, botY + 28, cx + 30, botY);
    ctx.strokeStyle = COLORS.lora;
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 3]);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;

    const drawMatrix = function(mx, my, label) {
      const bw = 20, bh = 14;
      drawRoundRect(mx - bw / 2, my - bh / 2, bw, bh, 3);
      ctx.fillStyle = COLORS.lora + '40';
      ctx.fill();
      ctx.strokeStyle = COLORS.lora;
      ctx.lineWidth = 1.2;
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 8px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(label, mx, my);
    };

    drawMatrix(cx - 18, topY - 28, 'A');
    drawMatrix(cx + 18, topY - 28, 'B');
    drawMatrix(cx - 18, botY + 28, 'A');
    drawMatrix(cx + 18, botY + 28, 'B');
    ctx.restore();
  }

  function getParticleColor() {
    if (currentMode === 'full') return COLORS.trainable;
    if (currentMode === 'adapter') return COLORS.accent;
    return COLORS.lora;
  }

  function updateParticles() {
    const endX = startX + totalW + 60;
    for (let p of particles) {
      p.x += p.speed;
      const wave = Math.sin((p.x - startX) * 0.02 + animFrame * 0.03) * 8;
      p.y = p.baseY + wave;
      if (p.x > endX) {
        p.x = startX - 30 - Math.random() * 50;
        p.y = p.baseY;
        p.alpha = 0.5 + Math.random() * 0.5;
      }
    }
  }

  function drawParticles(t) {
    const color = getParticleColor();
    for (let p of particles) {
      const fadeIn = Math.min(1, (p.x - (startX - 30)) / 40);
      const endX = startX + totalW + 30;
      const fadeOut = Math.min(1, (endX - p.x) / 40);
      const a = p.alpha * Math.max(0, Math.min(fadeIn, fadeOut));
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.globalAlpha = a;
      ctx.shadowColor = color;
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
  }

  function drawInputOutput() {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui, sans-serif';
    ctx.textAlign = 'center';
    const firstR = layerRect(0);
    const lastR = layerRect(LAYERS.length - 1);
    ctx.fillText('输入', firstR.x - 30, firstR.y + firstR.h / 2);
    ctx.beginPath();
    ctx.moveTo(firstR.x - 55, firstR.y + firstR.h / 2);
    ctx.lineTo(firstR.x - 8, firstR.y + firstR.h / 2);
    ctx.strokeStyle = 'rgba(148,163,184,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.fillText('输出', lastR.x + lastR.w + 30, lastR.y + lastR.h / 2);
    ctx.beginPath();
    ctx.moveTo(lastR.x + lastR.w + 8, lastR.y + lastR.h / 2);
    ctx.lineTo(lastR.x + lastR.w + 55, lastR.y + lastR.h / 2);
    ctx.stroke();
  }

  function drawModeLabel(t) {
    const info = INFO[currentMode];
    ctx.save();
    ctx.globalAlpha = easeInOut(Math.min(t, 1));
    ctx.fillStyle = info.color;
    ctx.font = 'bold 14px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.shadowColor = info.color;
    ctx.shadowBlur = 10;
    ctx.fillText(info.title + '  (' + info.params + ' 参数可训练)', W / 2, 18);
    ctx.restore();
  }

  function drawLegend() {
    const items = [
      { color: COLORS.trainable, label: '可训练层' },
      { color: COLORS.frozen, label: '冻结层' },
      { color: COLORS.accent, label: 'Adapter 模块' },
      { color: COLORS.lora, label: 'LoRA 旁路' }
    ];
    const y = H - 18;
    const totalLW = items.length * 90;
    let x = (W - totalLW) / 2;
    ctx.font = '10px system-ui, sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    for (const it of items) {
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fillStyle = it.color;
      ctx.fill();
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(it.label, x + 8, y);
      x += 100;
    }
  }

  function render() {
    animFrame++;
    if (transitionProgress < 1) {
      transitionProgress = Math.min(1, transitionProgress + 0.025);
    }
    const t = transitionProgress;

    ctx.clearRect(0, 0, W, H);

    for (let i = 0; i < LAYERS.length; i++) drawConnection(i);
    drawInputOutput();

    for (let i = 0; i < LAYERS.length; i++) drawLayer(i, t);

    if (currentMode === 'adapter') {
      for (let i = 0; i < LAYERS.length; i++) drawAdapterModule(i, t);
    }
    if (currentMode === 'lora') {
      for (let i = 0; i < LAYERS.length; i++) drawLoRABypass(i, t);
    }

    updateParticles();
    drawParticles(t);
    drawModeLabel(t);
    drawLegend();

    requestAnimationFrame(render);
  }

  function updateInfoPanel() {
    const info = INFO[currentMode];
    const panel = document.getElementById('infoPanel');
    panel.innerHTML = `
      <div class="info-title">
        <span class="dot" style="background:${info.color}"></span>
        ${info.title}
        <span style="font-size:0.85rem;color:#94a3b8;font-weight:400;margin-left:8px">可训练参数: ${info.params}</span>
      </div>
      <div class="info-grid">
        <div class="info-card pros"><h4>优势</h4><ul>${info.pros.map(p=>'<li>'+p+'</li>').join('')}</ul></div>
        <div class="info-card cons"><h4>不足</h4><ul>${info.cons.map(c=>'<li>'+c+'</li>').join('')}</ul></div>
      </div>`;
  }

  function updateStats() {
    const sec = document.getElementById('statsSection');
    let html = '<div class="stats-title">核心指标对比</div>';
    for (const s of STATS) {
      html += '<div class="stat-row"><div class="stat-label">' + s.label + '</div><div class="stat-bars">';
      const methods = [
        { key: 'full', label: '全量微调', color: COLORS.trainable, val: s.full },
        { key: 'adapter', label: 'Adapter', color: COLORS.accent, val: s.adapter },
        { key: 'lora', label: 'LoRA', color: COLORS.lora, val: s.lora }
      ];
      for (const m of methods) {
        const highlight = m.key === currentMode ? '1' : '0.45';
        html += `<div class="stat-bar-row" style="opacity:${highlight};transition:opacity 0.5s">
          <div class="stat-bar-label" style="color:${m.color}">${m.label}</div>
          <div class="stat-bar-track"><div class="stat-bar-fill" style="width:${m.val}%;background:${m.color}"></div></div>
          <div class="stat-val" style="color:${m.color}">${m.val}%</div></div>`;
      }
      html += '</div></div>';
    }
    html += `<div class="legend">
      <div class="legend-item"><div class="legend-dot" style="background:${COLORS.trainable}"></div>全量微调</div>
      <div class="legend-item"><div class="legend-dot" style="background:${COLORS.accent}"></div>Adapter</div>
      <div class="legend-item"><div class="legend-dot" style="background:${COLORS.lora}"></div>LoRA</div></div>`;
    sec.innerHTML = html;
  }

  window.switchMode = function(mode) {
    if (mode === currentMode) return;
    prevMode = currentMode;
    currentMode = mode;
    transitionProgress = 0;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
    document.querySelector('.mode-btn[data-mode="'+mode+'"]').classList.add('active');
    updateInfoPanel();
    updateStats();
  };

  initParticles();
  updateInfoPanel();
  updateStats();
  render();
})();
</script>

<script>
(function () {
  const sendHeight = () => {
    if (window.parent === window) return;
    const body = document.body;
    const root = document.documentElement;
    const height = Math.max(
      body ? body.scrollHeight : 0,
      body ? body.offsetHeight : 0,
      root ? root.scrollHeight : 0,
      root ? root.offsetHeight : 0
    );
    window.parent.postMessage({ type: 'iframe-height', height }, '*');
  };

  window.addEventListener('load', sendHeight);
  window.addEventListener('resize', sendHeight);

  if ('ResizeObserver' in window) {
    const observer = new ResizeObserver(sendHeight);
    if (document.body) observer.observe(document.body);
    if (document.documentElement) observer.observe(document.documentElement);
  }

  requestAnimationFrame(sendHeight);
  setTimeout(sendHeight, 250);
  setTimeout(sendHeight, 1000);
})();
</script>
</body>
</html>
