<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>协同过滤矩阵分解可视化</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #020617;
      --panel: #0f172a;
      --border: #1e293b;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --primary: #38bdf8;
      --good: #22c55e;
    }
    body {
      background: radial-gradient(circle at 15% 12%, #0f3b65 0%, #020617 55%);
      color: var(--text);
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
      padding: 20px;
    }
    .wrap {
      max-width: 980px;
      margin: 0 auto;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.96), rgba(2, 6, 23, 0.98));
      box-shadow: 0 20px 70px rgba(0, 0, 0, 0.5);
      padding: 20px;
    }
    h1 {
      font-size: 1.3rem;
      margin-bottom: 8px;
      background: linear-gradient(90deg, var(--primary), var(--good));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .sub {
      color: var(--muted);
      font-size: 0.92rem;
      line-height: 1.6;
      margin-bottom: 16px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    @media (max-width: 920px) {
      .grid { grid-template-columns: 1fr; }
    }
    .panel {
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.72);
      padding: 10px;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(2, 6, 23, 0.66);
    }
    .name { color: var(--muted); font-size: 0.84rem; margin-bottom: 8px; }
    .hint {
      margin-top: 12px;
      color: #cbd5e1;
      line-height: 1.6;
      font-size: 0.84rem;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Y ≈ XWᵀ + b 的几何直觉</h1>
    <p class="sub">
      左侧是稀疏评分矩阵 Y，中间是电影特征矩阵 X 与用户偏好矩阵 W，右侧是重建后的评分矩阵。你会看到“补全缺失评分”的核心过程。
    </p>

    <div class="grid">
      <section class="panel">
        <div class="name">原始评分矩阵 Y（含缺失）</div>
        <canvas id="yMat" width="260" height="220"></canvas>
      </section>
      <section class="panel">
        <div class="name">隐向量空间（X, W）</div>
        <canvas id="latent" width="260" height="220"></canvas>
      </section>
      <section class="panel">
        <div class="name">重建评分矩阵 Ŷ</div>
        <canvas id="yHat" width="260" height="220"></canvas>
      </section>
    </div>

    <p class="hint">提示：实际训练时通过最小化损失，让 Ŷ 在已评分位置逼近 Y，并在未评分位置给出合理预测。</p>
  </div>

  <script>
    const y = [
      [5, 4, null, 2],
      [null, 3, 2, null],
      [4, null, 5, 3],
      [2, 2, null, 4],
    ];
    const X = [
      [1.3, 0.4],
      [0.5, 1.2],
      [1.5, 1.4],
      [0.8, 0.3],
    ];
    const W = [
      [1.2, 0.6],
      [0.9, 1.1],
      [1.4, 1.0],
      [0.7, 0.5],
    ];
    const b = [0.1, 0.0, 0.2, -0.1];

    function drawMatrix(canvasId, matrix, withMissing = false) {
      const c = document.getElementById(canvasId);
      const ctx = c.getContext('2d');
      const rows = matrix.length;
      const cols = matrix[0].length;
      const cellW = (c.width - 30) / cols;
      const cellH = (c.height - 30) / rows;
      ctx.clearRect(0, 0, c.width, c.height);

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const v = matrix[i][j];
          const x = 15 + j * cellW;
          const y0 = 15 + i * cellH;
          ctx.strokeStyle = 'rgba(148,163,184,0.35)';
          ctx.strokeRect(x, y0, cellW, cellH);

          if (v === null && withMissing) {
            ctx.fillStyle = 'rgba(100,116,139,0.22)';
            ctx.fillRect(x, y0, cellW, cellH);
            ctx.fillStyle = '#94a3b8';
            ctx.fillText('?', x + cellW * 0.45, y0 + cellH * 0.6);
            continue;
          }

          const ratio = Math.max(0, Math.min(1, (v - 1) / 4));
          ctx.fillStyle = `rgba(56,189,248,${0.2 + ratio * 0.6})`;
          ctx.fillRect(x, y0, cellW, cellH);
          ctx.fillStyle = '#e2e8f0';
          ctx.font = '12px Segoe UI';
          ctx.fillText(v.toFixed(1), x + cellW * 0.3, y0 + cellH * 0.6);
        }
      }
    }

    function drawLatent() {
      const c = document.getElementById('latent');
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);

      ctx.strokeStyle = 'rgba(148,163,184,0.45)';
      ctx.beginPath();
      ctx.moveTo(20, c.height / 2);
      ctx.lineTo(c.width - 20, c.height / 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(c.width / 2, 20);
      ctx.lineTo(c.width / 2, c.height - 20);
      ctx.stroke();

      const sx = (v) => c.width / 2 + v * 45;
      const sy = (v) => c.height / 2 - v * 45;

      X.forEach((m) => {
        ctx.beginPath();
        ctx.arc(sx(m[0]), sy(m[1]), 4.5, 0, Math.PI * 2);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
      });
      W.forEach((u) => {
        ctx.beginPath();
        ctx.rect(sx(u[0]) - 4, sy(u[1]) - 4, 8, 8);
        ctx.fillStyle = '#38bdf8';
        ctx.fill();
      });
    }

    function rebuild() {
      const yHat = X.map((xv) =>
        W.map((wv, j) => xv[0] * wv[0] + xv[1] * wv[1] + b[j])
      );
      return yHat;
    }

    function reportHeight() {
      const height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      window.parent.postMessage({ type: 'iframe-height', height }, '*');
    }

    window.addEventListener('load', () => {
      drawMatrix('yMat', y, true);
      drawLatent();
      drawMatrix('yHat', rebuild());
      reportHeight();
      const ro = new ResizeObserver(reportHeight);
      ro.observe(document.body);
      ro.observe(document.documentElement);
      setTimeout(reportHeight, 120);
    });
  </script>
</body>
</html>

