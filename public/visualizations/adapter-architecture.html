<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Adapter 模块架构可视化</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0f172a; --bg-card: #1e293b; --bg-card-alt: #162032;
    --text: #e2e8f0; --text-dim: #94a3b8; --text-bright: #f8fafc;
    --primary: #3b82f6; --accent: #10b981; --frozen: #64748b;
    --trainable: #ef4444; --adapter-green: #22c55e;
    --border: #334155; --radius: 12px;
  }
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: var(--bg); color: var(--text);
    line-height: 1.6; overflow-x: hidden;
  }
  .container { max-width: 1100px; margin: 0 auto; padding: 24px 16px; }
  h1 {
    text-align: center; font-size: 1.8rem; font-weight: 700;
    background: linear-gradient(135deg, var(--primary), var(--adapter-green));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin-bottom: 6px;
  }
  .subtitle { text-align: center; color: var(--text-dim); font-size: 0.95rem; margin-bottom: 32px; }
  .section-title {
    font-size: 1.15rem; font-weight: 600; color: var(--text-bright);
    margin-bottom: 16px; padding-left: 12px;
    border-left: 3px solid var(--adapter-green);
  }

  /* --- Grid Layout --- */
  .main-grid { display: grid; grid-template-columns: 320px 1fr; gap: 24px; margin-bottom: 28px; }
  @media (max-width: 800px) { .main-grid { grid-template-columns: 1fr; } }

  .card {
    background: var(--bg-card); border: 1px solid var(--border);
    border-radius: var(--radius); padding: 20px; position: relative; overflow: hidden;
  }
  .card::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px;
    background: linear-gradient(90deg, var(--primary), var(--adapter-green));
  }

  /* --- Transformer Stack --- */
  .layer-stack { display: flex; flex-direction: column; gap: 6px; }
  .layer-group {
    border: 1px dashed var(--border); border-radius: 8px; padding: 8px;
    position: relative;
  }
  .layer-label {
    position: absolute; top: -9px; left: 12px; background: var(--bg-card);
    padding: 0 6px; font-size: 0.7rem; color: var(--text-dim);
  }
  .layer-block {
    display: flex; align-items: center; gap: 4px; padding: 5px 8px;
    border-radius: 6px; font-size: 0.72rem; margin-bottom: 4px;
    transition: all 0.3s;
  }
  .layer-block:last-child { margin-bottom: 0; }
  .frozen-block {
    background: rgba(100,116,139,0.15); border: 1px solid rgba(100,116,139,0.3);
    color: var(--frozen);
  }
  .frozen-block::before { content: '\2744\FE0F'; margin-right: 2px; font-size: 0.7rem; }
  .adapter-block {
    background: rgba(34,197,94,0.12); border: 1px solid rgba(34,197,94,0.35);
    color: var(--adapter-green); animation: adapterPulse 2.5s ease-in-out infinite;
  }
  .adapter-block::before { content: '\1F525'; margin-right: 2px; font-size: 0.7rem; }
  @keyframes adapterPulse {
    0%,100% { box-shadow: 0 0 0 0 rgba(34,197,94,0); }
    50% { box-shadow: 0 0 8px 2px rgba(34,197,94,0.2); }
  }
  .arrow-down {
    text-align: center; color: var(--text-dim); font-size: 0.8rem;
    line-height: 1; padding: 1px 0;
  }

  /* --- Bottleneck SVG --- */
  .bottleneck-container { position: relative; }
  #bottleneckCanvas { width: 100%; display: block; }

  /* --- Slider --- */
  .slider-section {
    display: grid; grid-template-columns: 1fr 1fr; gap: 16px;
    margin-bottom: 28px;
  }
  @media (max-width: 800px) { .slider-section { grid-template-columns: 1fr; } }
  .slider-wrap { display: flex; flex-direction: column; gap: 10px; }
  .slider-row { display: flex; align-items: center; gap: 12px; }
  .slider-row label { font-size: 0.85rem; color: var(--text-dim); white-space: nowrap; }
  .slider-row input[type=range] { flex: 1; accent-color: var(--adapter-green); cursor: pointer; }
  .slider-val {
    min-width: 38px; text-align: center; font-weight: 700; font-size: 1rem;
    color: var(--adapter-green);
  }
  .param-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .param-card {
    background: var(--bg-card-alt); border-radius: 8px; padding: 10px 12px;
    border: 1px solid var(--border);
  }
  .param-label { font-size: 0.72rem; color: var(--text-dim); }
  .param-value { font-size: 1.05rem; font-weight: 700; color: var(--text-bright); }
  .param-value.green { color: var(--adapter-green); }
  .param-value.blue { color: var(--primary); }

  /* --- Residual Toggle --- */
  .residual-section {
    display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 28px;
  }
  @media (max-width: 800px) { .residual-section { grid-template-columns: 1fr; } }
  .toggle-btn {
    display: inline-flex; align-items: center; gap: 8px; padding: 8px 18px;
    border-radius: 20px; border: 1px solid var(--adapter-green);
    background: rgba(34,197,94,0.1); color: var(--adapter-green);
    cursor: pointer; font-size: 0.85rem; transition: all 0.3s; margin-bottom: 12px;
  }
  .toggle-btn:hover { background: rgba(34,197,94,0.2); }
  .toggle-btn.active { background: var(--adapter-green); color: var(--bg); font-weight: 600; }
  .formula {
    font-family: 'Cambria Math', Georgia, serif; font-size: 1.1rem;
    text-align: center; padding: 12px; background: var(--bg-card-alt);
    border-radius: 8px; color: var(--text-bright); margin-bottom: 8px;
    border: 1px solid var(--border);
  }
  .formula-desc { text-align: center; font-size: 0.82rem; color: var(--text-dim); }
  #residualCanvas { width: 100%; height: 180px; display: block; }

  /* --- Analogy --- */
  .analogy-section { margin-bottom: 28px; }
  .analogy-visual {
    display: flex; align-items: center; justify-content: center;
    gap: 20px; padding: 24px 0; flex-wrap: wrap;
  }
  .analogy-item { text-align: center; }
  .analogy-icon { font-size: 3rem; display: block; margin-bottom: 4px; }
  .analogy-label { font-size: 0.78rem; color: var(--text-dim); }
  .analogy-op { font-size: 1.8rem; color: var(--text-dim); font-weight: 300; }
  .analogy-text {
    text-align: center; font-size: 0.95rem; color: var(--accent);
    padding: 12px 20px; background: rgba(16,185,129,0.08);
    border-radius: 8px; border: 1px solid rgba(16,185,129,0.2);
    max-width: 500px; margin: 0 auto;
  }

  /* --- Stats --- */
  .stats-section { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; margin-bottom: 28px; }
  @media (max-width: 800px) { .stats-section { grid-template-columns: 1fr; } }
  .stat-row {
    display: flex; justify-content: space-between; align-items: center;
    padding: 10px 0; border-bottom: 1px solid rgba(51,65,85,0.5);
  }
  .stat-row:last-child { border-bottom: none; }
  .stat-name { font-size: 0.85rem; color: var(--text-dim); }
  .stat-val { font-size: 1.1rem; font-weight: 700; }
  .donut-wrap { display: flex; justify-content: center; align-items: center; }
  #donutCanvas { width: 220px; height: 220px; }

  /* --- Footer --- */
  .footer { text-align: center; color: var(--text-dim); font-size: 0.75rem; padding: 16px 0; border-top: 1px solid var(--border); }
</style>
</head>
<body>
<div class="container">
  <h1>Adapter 模块架构可视化</h1>
  <p class="subtitle">瓶颈结构 (Bottleneck Architecture) -- 高效参数微调方法</p>

  <!-- Row 1: Transformer Stack + Bottleneck Detail -->
  <div class="main-grid">
    <!-- Left: Transformer Stack -->
    <div class="card">
      <div class="section-title">Transformer 编码器层</div>
      <div class="layer-stack" id="layerStack"></div>
    </div>
    <!-- Right: Bottleneck Detail -->
    <div class="card bottleneck-container">
      <div class="section-title">Adapter 瓶颈结构详解</div>
      <canvas id="bottleneckCanvas" height="420"></canvas>
    </div>
  </div>

  <!-- Row 2: Slider + Params -->
  <div class="slider-section">
    <div class="card">
      <div class="section-title">交互式参数调节</div>
      <div class="slider-wrap">
        <div class="slider-row">
          <label>模型维度 d =</label>
          <span class="slider-val" style="color:var(--primary)">768</span>
        </div>
        <div class="slider-row">
          <label>瓶颈维度 m =</label>
          <input type="range" id="mSlider" min="0" max="5" step="1" value="3">
          <span class="slider-val" id="mVal">64</span>
        </div>
        <div style="font-size:0.75rem;color:var(--text-dim);text-align:center;margin-top:4px;">
          拖动滑块观察瓶颈形状与参数变化
        </div>
      </div>
    </div>
    <div class="card">
      <div class="section-title">参数计算</div>
      <div class="param-grid">
        <div class="param-card">
          <div class="param-label">降维参数 (d x m)</div>
          <div class="param-value blue" id="downP">49,152</div>
        </div>
        <div class="param-card">
          <div class="param-label">升维参数 (m x d)</div>
          <div class="param-value blue" id="upP">49,152</div>
        </div>
        <div class="param-card">
          <div class="param-label">Adapter 总参数</div>
          <div class="param-value green" id="totalP">98,304</div>
        </div>
        <div class="param-card">
          <div class="param-label">参数开销占比</div>
          <div class="param-value green" id="overheadP">4.1%</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Row 3: Residual + Donut -->
  <div class="residual-section">
    <div class="card">
      <div class="section-title">残差连接机制</div>
      <div style="text-align:center;margin-bottom:8px;">
        <button class="toggle-btn active" id="btnZero" onclick="setResMode(true)">零映射模式</button>
        <button class="toggle-btn" id="btnNormal" onclick="setResMode(false)">正常训练模式</button>
      </div>
      <div class="formula" id="formulaBox">output = x + 0 = x</div>
      <div class="formula-desc" id="formulaDesc">初始化时 Adapter 输出接近零，模型行为与原始一致</div>
      <canvas id="residualCanvas"></canvas>
    </div>
    <div class="card">
      <div class="section-title">参数占比统计</div>
      <div class="stat-row">
        <span class="stat-name">原始层参数</span>
        <span class="stat-val" style="color:var(--frozen)" id="origStat">~2.36M</span>
      </div>
      <div class="stat-row">
        <span class="stat-name">Adapter 额外参数</span>
        <span class="stat-val" style="color:var(--adapter-green)" id="adapterStat">~98K</span>
      </div>
      <div class="stat-row">
        <span class="stat-name">参数开销</span>
        <span class="stat-val" style="color:var(--primary)" id="overheadStat">~4.1%</span>
      </div>
      <div class="donut-wrap"><canvas id="donutCanvas"></canvas></div>
    </div>
  </div>

  <!-- Row 4: Analogy -->
  <div class="card analogy-section">
    <div class="section-title">直观类比</div>
    <div class="analogy-visual">
      <div class="analogy-item">
        <span class="analogy-icon" id="brainIcon">&#129504;</span>
        <span class="analogy-label">预训练模型 (冻结)</span>
      </div>
      <span class="analogy-op">+</span>
      <div class="analogy-item">
        <span class="analogy-icon" id="glassesIcon" style="cursor:pointer;" onclick="toggleGlasses()">&#128083;</span>
        <span class="analogy-label">Adapter (可训练)</span>
      </div>
      <span class="analogy-op">=</span>
      <div class="analogy-item">
        <span class="analogy-icon">&#127775;</span>
        <span class="analogy-label">增强后的模型</span>
      </div>
    </div>
    <div class="analogy-text">
      Adapter 就像给预训练模型戴上有色眼镜 -- 不改变大脑本身，只通过小巧的适配器改变"看世界的方式"
    </div>
  </div>

  <div class="footer">Adapter 架构可视化 | 基于 Houlsby et al. 2019</div>
</div>

<script>
// ===== Constants =====
const D = 768;
const M_VALUES = [8, 16, 32, 64, 128, 256];
const ORIG_PARAMS = 2361600; // approx for a typical Transformer layer
let currentM = 64;
let resZeroMode = true;
let glassesOn = true;

// ===== Build Transformer Stack =====
(function buildStack() {
  const stack = document.getElementById('layerStack');
  const layers = [
    { label: '编码器层 2', id: 2 },
    { label: '编码器层 1', id: 1 },
  ];
  layers.forEach((l, li) => {
    const g = document.createElement('div');
    g.className = 'layer-group';
    g.innerHTML = `<span class="layer-label">${l.label}</span>`;
    const blocks = [
      { text: '多头自注意力 (Multi-Head Attention)', frozen: true },
      { text: 'Adapter 模块', frozen: false },
      { text: 'Add & Layer Norm', frozen: true },
      { text: '前馈网络 (FFN)', frozen: true },
      { text: 'Adapter 模块', frozen: false },
      { text: 'Add & Layer Norm', frozen: true },
    ];
    blocks.forEach((b, bi) => {
      const div = document.createElement('div');
      div.className = 'layer-block ' + (b.frozen ? 'frozen-block' : 'adapter-block');
      div.textContent = b.text;
      g.appendChild(div);
      if (bi < blocks.length - 1) {
        const arrow = document.createElement('div');
        arrow.className = 'arrow-down';
        arrow.textContent = '\u2193';
        g.appendChild(arrow);
      }
    });
    stack.appendChild(g);
    if (li < layers.length - 1) {
      const sep = document.createElement('div');
      sep.className = 'arrow-down';
      sep.innerHTML = '\u22EE';
      sep.style.fontSize = '1.1rem';
      stack.appendChild(sep);
    }
  });
})();

// ===== Bottleneck Canvas =====
const bnkCvs = document.getElementById('bottleneckCanvas');
const bnkCtx = bnkCvs.getContext('2d');
let particles = [];
let residualParticles = [];
let bnkAnimId;

function resizeBnkCanvas() {
  const rect = bnkCvs.parentElement.getBoundingClientRect();
  bnkCvs.width = rect.width - 40;
  bnkCvs.height = 420;
}
resizeBnkCanvas();
window.addEventListener('resize', () => { resizeBnkCanvas(); drawBottleneck(); });

function lerp(a, b, t) { return a + (b - a) * t; }

function drawBottleneck() {
  const W = bnkCvs.width, H = bnkCvs.height;
  const ctx = bnkCtx;
  ctx.clearRect(0, 0, W, H);

  const cx = W / 2;
  const dW = Math.min(W * 0.7, 350);
  const mRatio = currentM / 256;
  const mW = Math.max(24, dW * mRatio * 0.65 + 24);

  // Vertical layout positions
  const yInput = 40, yDown = 120, yRelu = 190, yUp = 260, yOutput = 340;
  const barH = 26;

  // --- Residual path (dashed, left side) ---
  const resX = cx - dW / 2 - 28;
  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = 'rgba(59,130,246,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(resX, yInput + barH / 2);
  ctx.lineTo(resX, yOutput + barH / 2);
  ctx.lineTo(cx - dW / 2, yOutput + barH / 2);
  ctx.stroke();
  ctx.setLineDash([]);
  // Arrowhead
  ctx.fillStyle = 'rgba(59,130,246,0.6)';
  ctx.beginPath();
  ctx.moveTo(cx - dW / 2, yOutput + barH / 2);
  ctx.lineTo(cx - dW / 2 - 7, yOutput + barH / 2 - 4);
  ctx.lineTo(cx - dW / 2 - 7, yOutput + barH / 2 + 4);
  ctx.closePath(); ctx.fill();
  // Label
  ctx.font = '11px system-ui';
  ctx.fillStyle = 'rgba(59,130,246,0.7)';
  ctx.textAlign = 'center';
  ctx.fillText('残差', resX - 2, (yInput + yOutput) / 2 + 4);
  ctx.restore();

  // Helper: draw rounded bar
  function drawBar(y, w, color, label, sub) {
    const x = cx - w / 2;
    const grad = ctx.createLinearGradient(x, y, x + w, y);
    grad.addColorStop(0, color); grad.addColorStop(1, shiftColor(color, 20));
    ctx.fillStyle = grad;
    roundRect(ctx, x, y, w, barH, 6);
    ctx.fillStyle = '#f8fafc';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, cx, y + barH / 2 + 4);
    if (sub) {
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText(sub, cx, y + barH + 14);
    }
  }

  // Helper: draw funnel between two bars
  function drawFunnel(y1, w1, y2, w2, color) {
    const grad = ctx.createLinearGradient(0, y1 + barH, 0, y2);
    grad.addColorStop(0, color + '60'); grad.addColorStop(1, color + '30');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(cx - w1 / 2, y1 + barH);
    ctx.lineTo(cx - w2 / 2, y2);
    ctx.lineTo(cx + w2 / 2, y2);
    ctx.lineTo(cx + w1 / 2, y1 + barH);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = color + '40'; ctx.lineWidth = 1; ctx.stroke();
  }

  // Draw funnels
  drawFunnel(yInput, dW, yDown, mW, '#22c55e');
  drawFunnel(yUp, mW, yOutput - 20, dW, '#22c55e');

  // ReLU area
  const reluW = mW + 10;
  ctx.fillStyle = 'rgba(239,68,68,0.06)';
  roundRect(ctx, cx - reluW / 2, yRelu - 8, reluW, barH + 16, 8);
  // Draw tiny ReLU graph
  ctx.save();
  ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2;
  ctx.beginPath();
  const rGx = cx - 20, rGy = yRelu + barH / 2;
  ctx.moveTo(rGx - 16, rGy + 6);
  ctx.lineTo(rGx, rGy);
  ctx.lineTo(rGx + 16, rGy - 10);
  ctx.stroke();
  ctx.fillStyle = '#ef4444'; ctx.font = '10px system-ui'; ctx.textAlign = 'left';
  ctx.fillText('ReLU', rGx + 20, rGy + 3);
  ctx.restore();

  // Draw bars
  drawBar(yInput, dW, '#3b82f6', '输入', 'd = ' + D);
  drawBar(yDown, mW, '#22c55e', '降维', 'd \u2192 m = ' + currentM);
  drawBar(yUp, mW, '#22c55e', '升维', 'm \u2192 d = ' + D);
  drawBar(yOutput, dW, '#3b82f6', '输出 + 残差', 'output = x + adapter(x)');

  // --- Animate particles ---
  const now = performance.now() / 1000;
  // Main path particles
  for (let i = 0; i < 8; i++) {
    const t = ((now * 0.35 + i * 0.125) % 1);
    let px, py, sz;
    if (t < 0.3) {
      const lt = t / 0.3;
      px = cx; py = lerp(yInput + barH, yDown, lt);
      sz = lerp(5, 3 * (mW / dW) + 2, lt);
    } else if (t < 0.5) {
      const lt = (t - 0.3) / 0.2;
      px = cx; py = lerp(yDown + barH, yUp, lt);
      sz = 3 * (mW / dW) + 2;
    } else if (t < 0.8) {
      const lt = (t - 0.5) / 0.3;
      px = cx; py = lerp(yUp + barH, yOutput, lt);
      sz = lerp(3 * (mW / dW) + 2, 5, lt);
    } else {
      continue;
    }
    ctx.beginPath();
    ctx.arc(px + Math.sin(now * 3 + i) * 4, py, sz, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(34,197,94,${0.7 - t * 0.3})`;
    ctx.fill();
  }

  // Residual particles
  for (let i = 0; i < 4; i++) {
    const t = ((now * 0.3 + i * 0.25) % 1);
    let rpx, rpy;
    if (t < 0.7) {
      rpx = resX; rpy = lerp(yInput + barH / 2, yOutput + barH / 2, t / 0.7);
    } else {
      const lt = (t - 0.7) / 0.3;
      rpx = lerp(resX, cx - dW / 2 + 10, lt);
      rpy = yOutput + barH / 2;
    }
    ctx.beginPath();
    ctx.arc(rpx, rpy, 3, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(59,130,246,${0.6})`;
    ctx.fill();
  }

  bnkAnimId = requestAnimationFrame(drawBottleneck);
}

function roundRect(ctx, x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath(); ctx.fill();
}

function shiftColor(hex, amt) {
  let r = parseInt(hex.slice(1, 3), 16) + amt;
  let g = parseInt(hex.slice(3, 5), 16) + amt;
  let b = parseInt(hex.slice(5, 7), 16) + amt;
  r = Math.min(255, Math.max(0, r));
  g = Math.min(255, Math.max(0, g));
  b = Math.min(255, Math.max(0, b));
  return `rgb(${r},${g},${b})`;
}

drawBottleneck();

// ===== Slider =====
const mSlider = document.getElementById('mSlider');
mSlider.addEventListener('input', () => {
  currentM = M_VALUES[mSlider.value];
  document.getElementById('mVal').textContent = currentM;
  updateParams();
});

function updateParams() {
  const down = D * currentM;
  const up = currentM * D;
  const total = down + up;
  const overhead = (total / ORIG_PARAMS * 100);
  document.getElementById('downP').textContent = down.toLocaleString();
  document.getElementById('upP').textContent = up.toLocaleString();
  document.getElementById('totalP').textContent = total.toLocaleString();
  document.getElementById('overheadP').textContent = overhead.toFixed(1) + '%';
  // Stats
  document.getElementById('adapterStat').textContent = '~' + (total / 1000).toFixed(0) + 'K';
  document.getElementById('overheadStat').textContent = '~' + overhead.toFixed(1) + '%';
  drawDonut(overhead);
}

// ===== Residual Toggle =====
function setResMode(isZero) {
  resZeroMode = isZero;
  document.getElementById('btnZero').classList.toggle('active', isZero);
  document.getElementById('btnNormal').classList.toggle('active', !isZero);
  if (isZero) {
    document.getElementById('formulaBox').textContent = 'output = x + 0 = x';
    document.getElementById('formulaDesc').textContent = '初始化时 Adapter 输出接近零，模型行为与原始一致';
  } else {
    document.getElementById('formulaBox').textContent = 'output = x + \u03b4 (增强特征)';
    document.getElementById('formulaDesc').textContent = '训练后 Adapter 学到有用特征 \u03b4，增强模型表现';
  }
  drawResidual();
}

// Residual Canvas
const resCvs = document.getElementById('residualCanvas');
const resCtx = resCvs.getContext('2d');
let resAnimId;

function resizeResCvs() {
  const rect = resCvs.parentElement.getBoundingClientRect();
  resCvs.width = rect.width - 40;
  resCvs.height = 180;
}
resizeResCvs();
window.addEventListener('resize', resizeResCvs);

function drawResidual() {
  if (resAnimId) cancelAnimationFrame(resAnimId);
  function frame() {
    const W = resCvs.width, H = resCvs.height;
    resCtx.clearRect(0, 0, W, H);
    const cx = W / 2, cy = H / 2;
    const now = performance.now() / 1000;

    // x input line
    resCtx.strokeStyle = '#3b82f6'; resCtx.lineWidth = 2;
    resCtx.beginPath(); resCtx.moveTo(40, cy); resCtx.lineTo(cx - 60, cy); resCtx.stroke();

    // Adapter box
    const bw = 80, bh = 40;
    resCtx.fillStyle = 'rgba(34,197,94,0.15)';
    resCtx.strokeStyle = '#22c55e'; resCtx.lineWidth = 1.5;
    roundRect(resCtx, cx - bw / 2, cy - bh / 2, bw, bh, 6);
    resCtx.stroke();
    resCtx.fillStyle = '#22c55e'; resCtx.font = 'bold 11px system-ui'; resCtx.textAlign = 'center';
    resCtx.fillText('Adapter', cx, cy + 4);

    // Adapter -> output (delta)
    if (!resZeroMode) {
      resCtx.strokeStyle = '#22c55e'; resCtx.lineWidth = 2;
      resCtx.beginPath(); resCtx.moveTo(cx + bw / 2, cy); resCtx.lineTo(cx + 90, cy); resCtx.stroke();
      // delta particle
      for (let i = 0; i < 3; i++) {
        const t = ((now * 0.5 + i * 0.33) % 1);
        const px = lerp(cx + bw / 2, cx + 90, t);
        resCtx.beginPath(); resCtx.arc(px, cy, 3, 0, Math.PI * 2);
        resCtx.fillStyle = `rgba(34,197,94,${0.8 - t * 0.5})`; resCtx.fill();
      }
      // \u03b4 label
      resCtx.fillStyle = '#22c55e'; resCtx.font = 'bold 14px serif';
      resCtx.fillText('\u03b4', cx + bw / 2 + 48, cy - 12);
    } else {
      // Zero output
      resCtx.strokeStyle = 'rgba(100,116,139,0.4)'; resCtx.lineWidth = 1;
      resCtx.setLineDash([4, 4]);
      resCtx.beginPath(); resCtx.moveTo(cx + bw / 2, cy); resCtx.lineTo(cx + 90, cy); resCtx.stroke();
      resCtx.setLineDash([]);
      resCtx.fillStyle = '#64748b'; resCtx.font = 'bold 14px serif';
      resCtx.fillText('0', cx + bw / 2 + 48, cy - 12);
    }

    // Plus sign
    resCtx.fillStyle = '#f8fafc'; resCtx.font = 'bold 18px system-ui';
    resCtx.fillText('+', cx + 100, cy + 6);

    // Output line
    resCtx.strokeStyle = resZeroMode ? '#3b82f6' : '#8b5cf6';
    resCtx.lineWidth = 2;
    resCtx.beginPath(); resCtx.moveTo(cx + 115, cy); resCtx.lineTo(W - 40, cy); resCtx.stroke();

    // Labels
    resCtx.font = '11px system-ui'; resCtx.textAlign = 'center';
    resCtx.fillStyle = '#3b82f6';
    resCtx.fillText('x', 30, cy + 4);
    resCtx.fillStyle = resZeroMode ? '#3b82f6' : '#8b5cf6';
    resCtx.fillText(resZeroMode ? 'x' : 'x + \u03b4', W - 25, cy + 4);

    // Input particles
    for (let i = 0; i < 3; i++) {
      const t = ((now * 0.4 + i * 0.33) % 1);
      const px = lerp(40, cx - 60, t);
      resCtx.beginPath(); resCtx.arc(px, cy, 3, 0, Math.PI * 2);
      resCtx.fillStyle = `rgba(59,130,246,${0.8 - t * 0.4})`; resCtx.fill();
    }

    resAnimId = requestAnimationFrame(frame);
  }
  frame();
}
drawResidual();

// ===== Donut Chart =====
const donutCvs = document.getElementById('donutCanvas');
const donutCtx = donutCvs.getContext('2d');
donutCvs.width = 220; donutCvs.height = 220;

function drawDonut(pct) {
  const W = 220, H = 220, cx = W / 2, cy = H / 2, R = 80, r = 52;
  donutCtx.clearRect(0, 0, W, H);

  // Frozen slice
  donutCtx.beginPath();
  donutCtx.arc(cx, cy, R, 0, Math.PI * 2);
  donutCtx.arc(cx, cy, r, Math.PI * 2, 0, true);
  donutCtx.fillStyle = 'rgba(100,116,139,0.35)';
  donutCtx.fill();

  // Adapter slice
  const angle = (pct / 100) * Math.PI * 2;
  donutCtx.beginPath();
  donutCtx.moveTo(cx + R * Math.cos(-Math.PI / 2), cy + R * Math.sin(-Math.PI / 2));
  donutCtx.arc(cx, cy, R, -Math.PI / 2, -Math.PI / 2 + angle);
  donutCtx.lineTo(cx + r * Math.cos(-Math.PI / 2 + angle), cy + r * Math.sin(-Math.PI / 2 + angle));
  donutCtx.arc(cx, cy, r, -Math.PI / 2 + angle, -Math.PI / 2, true);
  donutCtx.closePath();
  const grad = donutCtx.createLinearGradient(cx - R, cy, cx + R, cy);
  grad.addColorStop(0, '#22c55e'); grad.addColorStop(1, '#10b981');
  donutCtx.fillStyle = grad;
  donutCtx.fill();

  // Center text
  donutCtx.fillStyle = '#f8fafc'; donutCtx.font = 'bold 22px system-ui'; donutCtx.textAlign = 'center';
  donutCtx.fillText(pct.toFixed(1) + '%', cx, cy + 2);
  donutCtx.fillStyle = '#94a3b8'; donutCtx.font = '11px system-ui';
  donutCtx.fillText('Adapter \u5360\u6BD4', cx, cy + 20);

  // Legend
  donutCtx.fillStyle = 'rgba(100,116,139,0.6)';
  donutCtx.fillRect(cx - 50, H - 22, 10, 10);
  donutCtx.fillStyle = '#94a3b8'; donutCtx.font = '10px system-ui'; donutCtx.textAlign = 'left';
  donutCtx.fillText('\u539F\u59CB\u53C2\u6570', cx - 36, H - 13);
  donutCtx.fillStyle = '#22c55e';
  donutCtx.fillRect(cx + 20, H - 22, 10, 10);
  donutCtx.fillStyle = '#94a3b8';
  donutCtx.fillText('Adapter', cx + 34, H - 13);
}
drawDonut(4.1);
updateParams();

// ===== Glasses Toggle =====
function toggleGlasses() {
  glassesOn = !glassesOn;
  const el = document.getElementById('glassesIcon');
  el.style.transition = 'transform 0.4s, opacity 0.4s';
  if (glassesOn) {
    el.style.transform = 'translateY(0) scale(1)';
    el.style.opacity = '1';
  } else {
    el.style.transform = 'translateY(-12px) scale(0.8)';
    el.style.opacity = '0.4';
  }
}
</script>
</body>
</html>