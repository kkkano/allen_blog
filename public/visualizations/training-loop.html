<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PyTorch 训练循环可视化</title>
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #0f172a;
    --bg-card: #1e293b;
    --text: #e2e8f0;
    --text-dim: #94a3b8;
    --primary: #3b82f6;
    --accent: #10b981;
    --warning: #f59e0b;
    --danger: #ef4444;
    --radius: 10px;
  }

  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    min-height: 100vh;
    overflow-x: hidden;
  }

  .page { max-width: 1200px; margin: 0 auto; padding: 24px 20px; }

  header {
    text-align: center;
    margin-bottom: 28px;
  }
  header h1 {
    font-size: 1.75rem;
    font-weight: 700;
    background: linear-gradient(135deg, var(--primary), var(--accent));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 6px;
  }
  header p { color: var(--text-dim); font-size: 0.9rem; }

  .layout {
    display: grid;
    grid-template-columns: 1fr 340px;
    gap: 24px;
    align-items: start;
  }

  /* ---- Circular Diagram ---- */
  .cycle-container {
    position: relative;
    width: 100%;
    aspect-ratio: 1 / 1;
    max-width: 560px;
    margin: 0 auto;
  }

  .cycle-svg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
  }

  .arrow-path {
    fill: none;
    stroke: #334155;
    stroke-width: 2.5;
    stroke-linecap: round;
  }
  .arrow-head {
    fill: #334155;
  }

  .step-node {
    position: absolute;
    width: 120px;
    height: 120px;
    margin-left: -60px;
    margin-top: -60px;
    border-radius: 50%;
    background: var(--bg-card);
    border: 2.5px solid #334155;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: border-color 0.4s, box-shadow 0.4s, transform 0.3s;
    z-index: 2;
  }
  .step-node:hover { transform: scale(1.06); }
  .step-node .num {
    font-size: 0.7rem;
    font-weight: 700;
    color: var(--text-dim);
    margin-bottom: 2px;
  }
  .step-node .zh {
    font-size: 0.85rem;
    font-weight: 600;
    text-align: center;
    line-height: 1.2;
  }
  .step-node .en {
    font-size: 0.6rem;
    color: var(--text-dim);
    margin-top: 2px;
    text-align: center;
  }

  .step-node.active {
    border-color: var(--primary);
    box-shadow: 0 0 24px rgba(59,130,246,0.45), 0 0 60px rgba(59,130,246,0.15);
    transform: scale(1.1);
  }
  .step-node.active .zh { color: #fff; }

  /* node color accents per step */
  .step-node[data-step="0"].active { border-color: var(--primary); box-shadow: 0 0 24px rgba(59,130,246,0.45); }
  .step-node[data-step="1"].active { border-color: var(--danger); box-shadow: 0 0 24px rgba(239,68,68,0.45); }
  .step-node[data-step="2"].active { border-color: var(--warning); box-shadow: 0 0 24px rgba(245,158,11,0.45); }
  .step-node[data-step="3"].active { border-color: var(--accent); box-shadow: 0 0 24px rgba(16,185,129,0.45); }
  .step-node[data-step="4"].active { border-color: #8b5cf6; box-shadow: 0 0 24px rgba(139,92,246,0.45); }

  .runner {
    position: absolute;
    width: 14px;
    height: 14px;
    margin-left: -7px;
    margin-top: -7px;
    border-radius: 50%;
    background: var(--primary);
    box-shadow: 0 0 16px rgba(59,130,246,0.7), 0 0 40px rgba(59,130,246,0.3);
    z-index: 3;
    transition: background 0.3s;
    pointer-events: none;
  }

  /* ---- Sidebar ---- */
  .sidebar { display: flex; flex-direction: column; gap: 16px; }

  .card {
    background: var(--bg-card);
    border-radius: var(--radius);
    border: 1px solid #1e293b;
    padding: 16px;
  }
  .card h3 {
    font-size: 0.85rem;
    color: var(--text-dim);
    margin-bottom: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Controls */
  .controls-row {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
  }
  .btn {
    padding: 8px 20px;
    border: none;
    border-radius: 6px;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
  }
  .btn-primary {
    background: var(--primary);
    color: #fff;
  }
  .btn-primary:hover { background: #2563eb; }

  .speed-control {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
  }
  .speed-control label {
    font-size: 0.8rem;
    color: var(--text-dim);
    white-space: nowrap;
  }
  .speed-control input[type="range"] {
    flex: 1;
    accent-color: var(--primary);
    min-width: 80px;
  }

  .epoch-display {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    margin-top: 10px;
  }
  .stat-box {
    flex: 1;
    background: rgba(59,130,246,0.08);
    border-radius: 8px;
    padding: 10px;
    text-align: center;
  }
  .stat-box .val {
    font-size: 1.4rem;
    font-weight: 700;
    color: var(--primary);
  }
  .stat-box .lbl {
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-top: 2px;
  }

  /* Code snippet area */
  .code-area {
    min-height: 80px;
  }
  .code-area .step-title {
    font-size: 1rem;
    font-weight: 700;
    margin-bottom: 4px;
  }
  .code-area .step-desc {
    font-size: 0.78rem;
    color: var(--text-dim);
    margin-bottom: 10px;
    line-height: 1.5;
  }
  .code-block {
    background: #0c1222;
    border-radius: 6px;
    padding: 10px 14px;
    font-family: 'Cascadia Code', 'Fira Code', Consolas, monospace;
    font-size: 0.82rem;
    color: var(--accent);
    border: 1px solid #1e293b;
    line-height: 1.6;
    overflow-x: auto;
  }
  .code-block .kw { color: var(--primary); }
  .code-block .fn { color: var(--warning); }
  .code-block .cm { color: #64748b; }

  /* Loss canvas */
  .canvas-wrap {
    position: relative;
    background: #0c1222;
    border-radius: 8px;
    border: 1px solid #1e293b;
    overflow: hidden;
  }
  .canvas-wrap canvas {
    display: block;
    width: 100%;
    height: 180px;
  }

  /* Responsive */
  @media (max-width: 860px) {
    .layout {
      grid-template-columns: 1fr;
    }
    .cycle-container { max-width: 420px; }
  }
</style>
</head>
<body>
<div class="page">
  <header>
    <h1>PyTorch 训练循环</h1>
    <p>交互式可视化 — 深度学习模型训练的五个核心步骤</p>
  </header>

  <div class="layout">
    <!-- Left: Circular Diagram -->
    <div>
      <div class="cycle-container" id="cycleContainer">
        <svg class="cycle-svg" id="cycleSvg"></svg>
        <!-- nodes injected by JS -->
        <div class="runner" id="runner"></div>
      </div>
    </div>

    <!-- Right: Sidebar -->
    <div class="sidebar">
      <div class="card">
        <h3>控制面板</h3>
        <div class="controls-row">
          <button class="btn btn-primary" id="btnPlay">暂停</button>
          <div class="speed-control">
            <label>速度</label>
            <input type="range" id="speedRange" min="1" max="10" value="4" step="1">
            <span id="speedLabel" style="font-size:0.8rem;min-width:28px;text-align:right;">4x</span>
          </div>
        </div>
        <div class="epoch-display">
          <div class="stat-box">
            <div class="val" id="epochVal">0</div>
            <div class="lbl">当前轮次 (Epoch)</div>
          </div>
          <div class="stat-box">
            <div class="val" id="lossVal">2.500</div>
            <div class="lbl">当前损失 (Loss)</div>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>当前步骤</h3>
        <div class="code-area" id="codeArea">
          <div class="step-title" id="stepTitle">前向传播</div>
          <div class="step-desc" id="stepDesc">将输入数据传入模型，计算预测输出。</div>
          <div class="code-block" id="codeBlock">outputs = model(**batch)</div>
        </div>
      </div>

      <div class="card">
        <h3>损失曲线</h3>
        <div class="canvas-wrap">
          <canvas id="lossCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function () {
  /* ---- Step Data ---- */
  const STEPS = [
    {
      zh: '前向传播', en: 'Forward Pass',
      code: 'outputs = model(**batch)',
      desc: '将一个批次的输入数据传入模型，经过各层运算，得到模型的预测输出和内部损失。',
      color: '#3b82f6'
    },
    {
      zh: '计算损失', en: 'Compute Loss',
      code: 'loss = outputs.loss',
      desc: '从模型输出中获取损失值，它衡量了预测结果与真实标签之间的差距。',
      color: '#ef4444'
    },
    {
      zh: '反向传播', en: 'Backward Pass',
      code: 'loss.backward()',
      desc: '通过自动微分引擎反向计算每个参数的梯度，为参数更新提供方向和幅度。',
      color: '#f59e0b'
    },
    {
      zh: '参数更新', en: 'Update Params',
      code: 'optimizer.step()',
      desc: '优化器根据计算出的梯度，按照学习率调整模型参数，使损失逐步降低。',
      color: '#10b981'
    },
    {
      zh: '梯度清零', en: 'Zero Gradients',
      code: 'optimizer.zero_grad()',
      desc: '清除上一步累积的梯度，防止梯度在多个批次之间错误累加。',
      color: '#8b5cf6'
    }
  ];

  const NUM = STEPS.length;
  const container = document.getElementById('cycleContainer');
  const svg = document.getElementById('cycleSvg');
  const runnerEl = document.getElementById('runner');

  /* ---- Layout Geometry ---- */
  let CX, CY, R;

  function nodeAngle(i) {
    return -Math.PI / 2 + (2 * Math.PI / NUM) * i;
  }

  function nodePos(i) {
    const a = nodeAngle(i);
    return { x: CX + R * Math.cos(a), y: CY + R * Math.sin(a) };
  }

  /* ---- Build Nodes ---- */
  const nodeEls = [];
  STEPS.forEach((s, i) => {
    const el = document.createElement('div');
    el.className = 'step-node';
    el.dataset.step = i;
    el.innerHTML = '<span class="num">步骤 ' + (i + 1) + '</span>'
      + '<span class="zh">' + s.zh + '</span>'
      + '<span class="en">' + s.en + '</span>';
    el.addEventListener('click', () => { setActiveStep(i); });
    container.appendChild(el);
    nodeEls.push(el);
  });

  /* ---- Draw Arrows (SVG) ---- */
  function buildArrows() {
    const w = container.clientWidth;
    const h = container.clientHeight;
    CX = w / 2;
    CY = h / 2;
    R = Math.min(CX, CY) * 0.62;

    svg.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
    svg.innerHTML = '<defs><marker id="ah" markerWidth="8" markerHeight="6" '
      + 'refX="7" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" class="arrow-head"/></marker></defs>';

    for (let i = 0; i < NUM; i++) {
      const j = (i + 1) % NUM;
      const p1 = nodePos(i);
      const p2 = nodePos(j);
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      const ux = dx / len;
      const uy = dy / len;
      const offset = 64;
      const sx = p1.x + ux * offset;
      const sy = p1.y + uy * offset;
      const ex = p2.x - ux * offset;
      const ey = p2.y - uy * offset;

      const mx = (sx + ex) / 2;
      const my = (sy + ey) / 2;
      const perpX = -uy;
      const perpY = ux;
      const bulge = len * 0.18;
      const cx1 = mx + perpX * bulge;
      const cy1 = my + perpY * bulge;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', 'M ' + sx + ' ' + sy + ' Q ' + cx1 + ' ' + cy1 + ' ' + ex + ' ' + ey);
      path.setAttribute('class', 'arrow-path');
      path.setAttribute('marker-end', 'url(#ah)');
      path.dataset.from = i;
      path.dataset.to = j;
      svg.appendChild(path);
    }

    /* position nodes */
    nodeEls.forEach((el, i) => {
      const p = nodePos(i);
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';
    });
  }

  /* ---- Animation State ---- */
  let playing = true;
  let currentStep = 0;
  let progress = 0;        // 0-1 within arc between two steps
  let speed = 4;
  let epoch = 0;
  let lossHistory = [];
  let currentLoss = 2.5;

  const btnPlay = document.getElementById('btnPlay');
  const speedRange = document.getElementById('speedRange');
  const speedLabel = document.getElementById('speedLabel');
  const epochVal = document.getElementById('epochVal');
  const lossValEl = document.getElementById('lossVal');
  const stepTitle = document.getElementById('stepTitle');
  const stepDesc = document.getElementById('stepDesc');
  const codeBlock = document.getElementById('codeBlock');

  btnPlay.addEventListener('click', () => {
    playing = !playing;
    btnPlay.textContent = playing ? '暂停' : '播放';
  });

  speedRange.addEventListener('input', () => {
    speed = parseInt(speedRange.value);
    speedLabel.textContent = speed + 'x';
  });

  /* ---- Runner Position ---- */
  function getRunnerPos(stepIdx, t) {
    const i = stepIdx;
    const j = (stepIdx + 1) % NUM;
    const p1 = nodePos(i);
    const p2 = nodePos(j);
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const ux = dx / len;
    const uy = dy / len;
    const offset = 64;
    const sx = p1.x + ux * offset;
    const sy = p1.y + uy * offset;
    const ex = p2.x - ux * offset;
    const ey = p2.y - uy * offset;

    const mx = (sx + ex) / 2;
    const my = (sy + ey) / 2;
    const perpX = -uy;
    const perpY = ux;
    const bulge = len * 0.18;
    const cpx = mx + perpX * bulge;
    const cpy = my + perpY * bulge;

    const u = t;
    const x = (1 - u) * (1 - u) * sx + 2 * (1 - u) * u * cpx + u * u * ex;
    const y = (1 - u) * (1 - u) * sy + 2 * (1 - u) * u * cpy + u * u * ey;
    return { x, y };
  }

  function setActiveStep(idx) {
    currentStep = idx;
    progress = 0;
    updateUI();
  }

  function updateUI() {
    nodeEls.forEach((el, i) => {
      el.classList.toggle('active', i === currentStep);
    });

    /* highlight arrow */
    svg.querySelectorAll('.arrow-path').forEach(p => {
      const from = parseInt(p.dataset.from);
      p.style.stroke = from === currentStep ? STEPS[currentStep].color : '#334155';
      p.style.strokeWidth = from === currentStep ? '3.5' : '2.5';
    });
    svg.querySelectorAll('.arrow-head').forEach(m => {
      /* marker color is harder; we rely on the CSS class default */
    });

    const s = STEPS[currentStep];
    stepTitle.textContent = '步骤 ' + (currentStep + 1) + '：' + s.zh;
    stepTitle.style.color = s.color;
    stepDesc.textContent = s.desc;
    codeBlock.innerHTML = highlightCode(s.code);
    runnerEl.style.background = s.color;
    runnerEl.style.boxShadow = '0 0 16px ' + s.color + 'b3, 0 0 40px ' + s.color + '4d';
  }

  function highlightCode(code) {
    return code
      .replace(/\b(model|loss|optimizer|outputs|batch)\b/g, '<span class="fn">$1</span>')
      .replace(/\b(backward|step|zero_grad)\b/g, '<span class="kw">$1</span>');
  }

  /* ---- Loss Curve (Canvas) ---- */
  const canvas = document.getElementById('lossCanvas');
  const ctx = canvas.getContext('2d');

  function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width * devicePixelRatio;
    canvas.height = 180 * devicePixelRatio;
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }

  function drawLoss() {
    const w = canvas.width / devicePixelRatio;
    const h = canvas.height / devicePixelRatio;
    ctx.clearRect(0, 0, w, h);

    if (lossHistory.length < 2) return;

    const padL = 40, padR = 12, padT = 16, padB = 28;
    const gw = w - padL - padR;
    const gh = h - padT - padB;

    const maxLoss = 3;
    const minLoss = 0;

    /* grid lines */
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    for (let v = 0; v <= 3; v += 0.5) {
      const y = padT + gh - (v / maxLoss) * gh;
      ctx.beginPath();
      ctx.moveTo(padL, y);
      ctx.lineTo(padL + gw, y);
      ctx.stroke();
    }

    /* axis labels */
    ctx.fillStyle = '#64748b';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'right';
    for (let v = 0; v <= 3; v += 1) {
      const y = padT + gh - (v / maxLoss) * gh;
      ctx.fillText(v.toFixed(1), padL - 6, y + 3);
    }
    ctx.textAlign = 'center';
    ctx.fillText('轮次 (Epoch)', padL + gw / 2, h - 4);

    /* draw line */
    const maxPts = 60;
    const pts = lossHistory.slice(-maxPts);
    const step = gw / Math.max(pts.length - 1, 1);

    /* gradient fill */
    const grad = ctx.createLinearGradient(0, padT, 0, padT + gh);
    grad.addColorStop(0, 'rgba(59,130,246,0.25)');
    grad.addColorStop(1, 'rgba(59,130,246,0)');
    ctx.beginPath();
    pts.forEach((v, i) => {
      const x = padL + i * step;
      const y = padT + gh - (Math.max(v, 0) / maxLoss) * gh;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    const lastX = padL + (pts.length - 1) * step;
    ctx.lineTo(lastX, padT + gh);
    ctx.lineTo(padL, padT + gh);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();

    /* line */
    ctx.beginPath();
    pts.forEach((v, i) => {
      const x = padL + i * step;
      const y = padT + gh - (Math.max(v, 0) / maxLoss) * gh;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.stroke();

    /* last point glow */
    if (pts.length > 0) {
      const lv = pts[pts.length - 1];
      const lx = padL + (pts.length - 1) * step;
      const ly = padT + gh - (Math.max(lv, 0) / maxLoss) * gh;
      ctx.beginPath();
      ctx.arc(lx, ly, 4, 0, Math.PI * 2);
      ctx.fillStyle = '#3b82f6';
      ctx.fill();
      ctx.beginPath();
      ctx.arc(lx, ly, 8, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(59,130,246,0.25)';
      ctx.fill();
    }
  }

  function advanceEpoch() {
    epoch++;
    /* simulated loss: exponential decay with noise */
    const base = 2.5 * Math.exp(-0.06 * epoch);
    const noise = (Math.random() - 0.5) * 0.15 * Math.max(1, 3 - epoch * 0.05);
    currentLoss = Math.max(0.01, base + noise);
    lossHistory.push(currentLoss);

    epochVal.textContent = epoch;
    lossValEl.textContent = currentLoss.toFixed(3);
    drawLoss();
  }

  /* ---- Main Loop ---- */
  let lastTime = 0;
  const DWELL = 0.35;   // seconds to pause on each node
  let dwellTimer = 0;
  let phase = 'dwell';  // 'dwell' | 'move'

  function tick(ts) {
    requestAnimationFrame(tick);
    if (!lastTime) { lastTime = ts; return; }
    const dt = Math.min((ts - lastTime) / 1000, 0.1);
    lastTime = ts;

    if (!playing) {
      /* still position runner at current step node */
      const p = nodePos(currentStep);
      runnerEl.style.left = p.x + 'px';
      runnerEl.style.top = p.y + 'px';
      return;
    }

    const spd = speed;

    if (phase === 'dwell') {
      dwellTimer += dt * spd;
      const p = nodePos(currentStep);
      runnerEl.style.left = p.x + 'px';
      runnerEl.style.top = p.y + 'px';

      if (dwellTimer >= DWELL) {
        dwellTimer = 0;
        phase = 'move';
        progress = 0;
      }
    } else {
      progress += dt * spd * 0.9;
      if (progress >= 1) {
        progress = 0;
        const prevStep = currentStep;
        currentStep = (currentStep + 1) % NUM;
        phase = 'dwell';
        dwellTimer = 0;
        updateUI();

        /* completed a full cycle? */
        if (currentStep === 0 && prevStep === NUM - 1) {
          advanceEpoch();
        }
      } else {
        const pos = getRunnerPos(currentStep, progress);
        runnerEl.style.left = pos.x + 'px';
        runnerEl.style.top = pos.y + 'px';
      }
    }
  }

  /* ---- Init ---- */
  function init() {
    buildArrows();
    resizeCanvas();
    updateUI();
    drawLoss();
    requestAnimationFrame(tick);
  }

  window.addEventListener('resize', () => {
    buildArrows();
    resizeCanvas();
    drawLoss();
  });

  init();
})();
</script>

<script>
(function () {
  const sendHeight = () => {
    if (window.parent === window) return;
    const body = document.body;
    const root = document.documentElement;
    const height = Math.max(
      body ? body.scrollHeight : 0,
      body ? body.offsetHeight : 0,
      root ? root.scrollHeight : 0,
      root ? root.offsetHeight : 0
    );
    window.parent.postMessage({ type: 'iframe-height', height }, '*');
  };

  window.addEventListener('load', sendHeight);
  window.addEventListener('resize', sendHeight);

  if ('ResizeObserver' in window) {
    const observer = new ResizeObserver(sendHeight);
    if (document.body) observer.observe(document.body);
    if (document.documentElement) observer.observe(document.documentElement);
  }

  requestAnimationFrame(sendHeight);
  setTimeout(sendHeight, 250);
  setTimeout(sendHeight, 1000);
})();
</script>
</body>
</html>
