<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LangGraph Reflection æµç¨‹å›¾åŠ¨æ€æ¼”ç¤º</title>
  <style>
    :root {
      --bg-1: #080f2d;
      --bg-2: #101b44;
      --card-bg: rgba(10, 20, 54, 0.88);
      --card-border: #2f4aa2;
      --text-main: #ebf1ff;
      --text-sub: #afc0ee;
      --accent: #7aa2ff;
      --line: #3f5cb8;
      --line-active: #ffbf5e;
      --node-gen: #4c7bff;
      --node-crit: #8d65ff;
      --node-rev: #2ec7a1;
      --node-stop: #f26d6d;
      --ok: #2dd4bf;
      --warn: #fbbf24;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 18px;
      min-height: 0;
      font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 12% 8%, #223881 0%, transparent 42%),
        radial-gradient(circle at 92% 88%, #1e2f6d 0%, transparent 36%),
        linear-gradient(145deg, var(--bg-1), var(--bg-2));
    }

    .wrap {
      max-width: 1080px;
      margin: 0 auto;
      border: 1px solid var(--card-border);
      border-radius: 16px;
      background: var(--card-bg);
      padding: 16px;
      box-shadow: 0 26px 56px rgba(0, 0, 0, 0.38);
      backdrop-filter: blur(5px);
    }

    .title {
      margin: 0;
      font-size: 1.45rem;
      line-height: 1.25;
      color: #8ec6ff;
      letter-spacing: 0.2px;
    }

    .subtitle {
      margin: 8px 0 14px;
      color: var(--text-sub);
      font-size: 0.92rem;
      line-height: 1.56;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 12px;
      align-items: start;
    }

    .panel {
      border: 1px solid #2a4294;
      border-radius: 12px;
      background: rgba(10, 20, 60, 0.72);
      padding: 12px;
    }

    .panel h3 {
      margin: 0 0 8px;
      font-size: 0.95rem;
      color: #cfe0ff;
      letter-spacing: 0.2px;
    }

    .flow-svg {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 10px;
      border: 1px solid #344f9f;
      background:
        radial-gradient(circle at 50% -10%, rgba(95, 125, 224, 0.18), transparent 60%),
        linear-gradient(180deg, rgba(7, 15, 40, 0.9), rgba(7, 12, 30, 0.95));
    }

    .node {
      fill: #15285f;
      stroke: #4a66c4;
      stroke-width: 2;
      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.28));
      transition: fill 0.2s ease, stroke 0.2s ease, opacity 0.2s ease;
    }

    .node-label {
      font-size: 14px;
      fill: #e9f1ff;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .node-sub {
      font-size: 11px;
      fill: #b5c7f6;
      text-anchor: middle;
      pointer-events: none;
    }

    .edge {
      stroke: var(--line);
      stroke-width: 3;
      fill: none;
      marker-end: url(#arrow);
      opacity: 0.75;
      transition: stroke 0.2s ease, opacity 0.2s ease;
    }

    .edge-label {
      fill: #9fb5ec;
      font-size: 11px;
      text-anchor: middle;
    }

    .edge.active {
      stroke: var(--line-active);
      opacity: 1;
      filter: drop-shadow(0 0 4px rgba(255, 191, 94, 0.55));
    }

    .node.active {
      stroke: #ffcb7c;
      stroke-width: 3;
      filter: drop-shadow(0 0 10px rgba(255, 205, 126, 0.45));
    }

    .node.done {
      stroke: #48e0bd;
      fill: #173d5b;
    }

    .node.gen.active {
      fill: #1f3f95;
    }

    .node.crit.active {
      fill: #392c85;
    }

    .node.rev.active {
      fill: #174a46;
    }

    .node.stop.active {
      fill: #5d2333;
    }

    .status-box {
      border: 1px solid #304a9d;
      border-radius: 10px;
      background: rgba(11, 19, 52, 0.85);
      padding: 10px;
      min-height: 100px;
      color: #d8e5ff;
      line-height: 1.55;
      font-size: 0.9rem;
    }

    .status-box strong {
      color: #f8fbff;
    }

    .controls {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .control {
      display: grid;
      gap: 6px;
    }

    .control-label {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      color: #c6d6ff;
      font-size: 0.83rem;
    }

    .val {
      color: #ffdca7;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 0.8rem;
      font-weight: 600;
    }

    input[type='range'] {
      width: 100%;
      accent-color: #7f9fff;
    }

    .btn-row {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      border: 1px solid #4f6fcf;
      border-radius: 999px;
      padding: 8px 14px;
      background: linear-gradient(135deg, #3c5ec6, #7058dc);
      color: #eff4ff;
      font-size: 0.86rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.16s ease, box-shadow 0.16s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(65, 96, 196, 0.32);
    }

    button.secondary {
      background: linear-gradient(135deg, #2c3f80, #2b346a);
      border-color: #4f6098;
    }

    .metrics {
      margin-top: 10px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .metric {
      border: 1px solid #334f9f;
      border-radius: 10px;
      padding: 9px;
      background: rgba(20, 34, 86, 0.5);
    }

    .metric-k {
      color: #aac0f3;
      font-size: 0.76rem;
      margin-bottom: 4px;
    }

    .metric-v {
      color: #f7faff;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .log {
      margin-top: 10px;
      border: 1px solid #2a4391;
      border-radius: 10px;
      background: #0a1336;
      padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color: #cbd9fe;
      font-size: 0.78rem;
      line-height: 1.56;
      max-height: 170px;
      overflow: auto;
      white-space: pre-wrap;
    }

    .legend {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      border: 1px solid #3656ad;
      border-radius: 999px;
      padding: 4px 8px;
      font-size: 0.74rem;
      color: #b9ccf7;
      background: rgba(16, 28, 73, 0.64);
    }

    .chip.ok {
      border-color: rgba(45, 212, 191, 0.5);
      color: #9ef2e4;
    }

    .chip.warn {
      border-color: rgba(251, 191, 36, 0.5);
      color: #ffe1a3;
    }

    @media (max-width: 930px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .controls {
        grid-template-columns: 1fr;
      }

      .metrics {
        grid-template-columns: 1fr 1fr;
      }
    }

    @media (max-width: 620px) {
      body {
        padding: 12px;
      }

      .title {
        font-size: 1.22rem;
      }

      .metrics {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1 class="title">ğŸ” LangGraph Reflectionï¼šæµç¨‹å›¾ + æ–‡å­—è”åŠ¨æ¼”ç¤º</h1>
    <p class="subtitle">ä¸æ˜¯â€œä¸€ä¸ªæ¡†é‡Œæ¢æ–‡å­—â€ï¼Œè€Œæ˜¯è®©ä½ çœ‹åˆ°èŠ‚ç‚¹çŠ¶æ€ã€è¿çº¿è·¯å¾„ã€åœæ­¢æ¡ä»¶å’ŒæŒ‡æ ‡å˜åŒ–ï¼š<code>Generator â†’ Critic â†’ Revise â†’ (Stop / Next Round)</code>ã€‚</p>

    <div class="layout">
      <div class="panel">
        <h3>æµç¨‹å›¾åŠ¨æ€è§†å›¾</h3>
        <svg class="flow-svg" viewBox="0 0 760 420" aria-label="LangGraph Reflection Flow">
          <defs>
            <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="5" orient="auto" markerUnits="strokeWidth">
              <path d="M0,0 L0,10 L10,5 z" fill="#5f7fd8"></path>
            </marker>
          </defs>

          <path id="edge-gc" class="edge" d="M230,95 C290,75 330,75 392,95"></path>
          <path id="edge-cr" class="edge" d="M546,95 C600,75 620,100 620,150 C620,200 600,225 546,245"></path>
          <path id="edge-rg" class="edge" d="M392,245 C332,270 292,270 230,245"></path>
          <path id="edge-rs" class="edge" d="M470,292 C470,322 470,328 470,350"></path>

          <text class="edge-label" x="310" y="70">è‰ç¨¿ + æ„å›¾</text>
          <text class="edge-label" x="634" y="174">æ‰¹è¯„å»ºè®®</text>
          <text class="edge-label" x="310" y="286">è¿­ä»£é‡å†™</text>
          <text class="edge-label" x="508" y="336">åœæ­¢åˆ¤å®š</text>

          <rect id="node-generator" class="node gen" x="60" y="52" rx="16" ry="16" width="170" height="86"></rect>
          <text class="node-label" x="145" y="85">Generator</text>
          <text class="node-sub" x="145" y="106">å¿«é€Ÿäº§å‡ºåˆç¨¿</text>

          <rect id="node-critic" class="node crit" x="392" y="52" rx="16" ry="16" width="170" height="86"></rect>
          <text class="node-label" x="477" y="85">Critic</text>
          <text class="node-sub" x="477" y="106">æ‰¹è¯„ä¸å»ºè®®</text>

          <rect id="node-revise" class="node rev" x="392" y="202" rx="16" ry="16" width="170" height="86"></rect>
          <text class="node-label" x="477" y="235">Revise</text>
          <text class="node-sub" x="477" y="256">æ”¹å†™ä¸ä¿®æ­£</text>

          <rect id="node-stop" class="node stop" x="385" y="350" rx="14" ry="14" width="184" height="56"></rect>
          <text class="node-label" x="477" y="380">Stop or Next Round</text>
        </svg>

        <div class="legend">
          <span class="chip">è“çº¿ï¼šæ­£å¸¸æµè½¬</span>
          <span class="chip warn">æ©™çº¿ï¼šå½“å‰æ¿€æ´»è·¯å¾„</span>
          <span class="chip ok">é’è¾¹ï¼šè¯¥èŠ‚ç‚¹æœ¬è½®å®Œæˆ</span>
        </div>
      </div>

      <div class="panel">
        <h3>æ–‡å­—è§£é‡Šä¸æ§åˆ¶</h3>
        <div class="status-box" id="statusBox">
          <strong>å‡†å¤‡å°±ç»ª</strong><br />
          ç‚¹å‡»â€œå•æ­¥æ‰§è¡Œâ€æˆ–â€œè‡ªåŠ¨æ’­æ”¾â€ï¼Œè§‚å¯Ÿæµç¨‹å›¾èŠ‚ç‚¹å’Œè¿çº¿å¦‚ä½•å˜åŒ–ã€‚
        </div>

        <div class="controls">
          <div class="control">
            <div class="control-label">æœ€å¤§è½®æ¬¡ <span id="roundsVal" class="val">3</span></div>
            <input id="maxRounds" type="range" min="1" max="8" step="1" value="3" />
          </div>
          <div class="control">
            <div class="control-label">è´¨é‡é˜ˆå€¼ <span id="qualityVal" class="val">88</span></div>
            <input id="qualityThreshold" type="range" min="70" max="98" step="1" value="88" />
          </div>
          <div class="control">
            <div class="control-label">æ‰¹è¯„å¼ºåº¦ <span id="critVal" class="val">1.20</span></div>
            <input id="criticStrength" type="range" min="0.6" max="2.0" step="0.1" value="1.2" />
          </div>
          <div class="control">
            <div class="control-label">æ’­æ”¾é€Ÿåº¦ <span id="speedVal" class="val">1.00</span></div>
            <input id="playSpeed" type="range" min="0.6" max="2.4" step="0.1" value="1.0" />
          </div>
        </div>

        <div class="btn-row">
          <button id="stepBtn">â­ å•æ­¥æ‰§è¡Œ</button>
          <button id="playBtn">â–¶ è‡ªåŠ¨æ’­æ”¾</button>
          <button class="secondary" id="resetBtn">â†º é‡ç½®</button>
        </div>

        <div class="metrics">
          <div class="metric"><div class="metric-k">å½“å‰è½®æ¬¡</div><div id="mRound" class="metric-v">0</div></div>
          <div class="metric"><div class="metric-k">å½“å‰é˜¶æ®µ</div><div id="mStage" class="metric-v">Idle</div></div>
          <div class="metric"><div class="metric-k">è´¨é‡è¯„åˆ†</div><div id="mQuality" class="metric-v">52</div></div>
          <div class="metric"><div class="metric-k">ç´¯è®¡ Token</div><div id="mToken" class="metric-v">0</div></div>
          <div class="metric"><div class="metric-k">é¢„è®¡å»¶è¿Ÿ(ms)</div><div id="mLatency" class="metric-v">180</div></div>
          <div class="metric"><div class="metric-k">åœæ­¢åŸå› </div><div id="mStop" class="metric-v">-</div></div>
        </div>

        <div id="logBox" class="log"></div>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const stages = ['generator', 'critic', 'revise', 'stop'];

      const stageConfig = {
        generator: {
          nodeId: 'node-generator',
          edgeId: 'edge-gc',
          label: 'Generator',
          text: 'Generator ç”Ÿæˆåˆç¨¿ï¼šå¿«é€Ÿè¦†ç›–é—®é¢˜ç©ºé—´ï¼Œä½†å¯èƒ½æœ‰äº‹å®é—æ¼æˆ–ç»“æ„æ¾æ•£ã€‚',
          tokenDelta: 190,
          qualityDelta: 3,
        },
        critic: {
          nodeId: 'node-critic',
          edgeId: 'edge-cr',
          label: 'Critic',
          text: 'Critic ç»™å‡ºç»“æ„åŒ–åé¦ˆï¼šæŒ‡å‡ºè¯æ®ä¸è¶³ã€é€»è¾‘è·³æ­¥ã€è¡¨è¾¾å†—é•¿ç­‰é—®é¢˜ã€‚',
          tokenDelta: 130,
          qualityDelta: 4,
        },
        revise: {
          nodeId: 'node-revise',
          edgeId: 'edge-rg',
          label: 'Revise',
          text: 'Revise æŒ‰åé¦ˆé‡å†™ï¼šè¡¥è¯æ®ã€ä¿®é€»è¾‘ã€æç‚¼è¡¨è¾¾ï¼Œå½¢æˆæ–°ç‰ˆæœ¬ã€‚',
          tokenDelta: 165,
          qualityDelta: 6,
        },
        stop: {
          nodeId: 'node-stop',
          edgeId: 'edge-rs',
          label: 'Stop Check',
          text: 'è¿›å…¥åœæ­¢åˆ¤å®šï¼šè‹¥è´¨é‡è¾¾åˆ°é˜ˆå€¼æˆ–è½®æ¬¡ç”¨å°½åˆ™ç»“æŸï¼Œå¦åˆ™å›åˆ° Generator å¼€å¯ä¸‹ä¸€è½®ã€‚',
          tokenDelta: 28,
          qualityDelta: 0,
        },
      };

      const nodes = {
        generator: document.getElementById('node-generator'),
        critic: document.getElementById('node-critic'),
        revise: document.getElementById('node-revise'),
        stop: document.getElementById('node-stop'),
      };

      const edges = {
        'edge-gc': document.getElementById('edge-gc'),
        'edge-cr': document.getElementById('edge-cr'),
        'edge-rg': document.getElementById('edge-rg'),
        'edge-rs': document.getElementById('edge-rs'),
      };

      const controls = {
        maxRounds: document.getElementById('maxRounds'),
        qualityThreshold: document.getElementById('qualityThreshold'),
        criticStrength: document.getElementById('criticStrength'),
        playSpeed: document.getElementById('playSpeed'),
      };

      const controlVals = {
        maxRounds: document.getElementById('roundsVal'),
        qualityThreshold: document.getElementById('qualityVal'),
        criticStrength: document.getElementById('critVal'),
        playSpeed: document.getElementById('speedVal'),
      };

      const metrics = {
        round: document.getElementById('mRound'),
        stage: document.getElementById('mStage'),
        quality: document.getElementById('mQuality'),
        token: document.getElementById('mToken'),
        latency: document.getElementById('mLatency'),
        stop: document.getElementById('mStop'),
      };

      const statusBox = document.getElementById('statusBox');
      const logBox = document.getElementById('logBox');

      const stepButton = document.getElementById('stepBtn');
      const playButton = document.getElementById('playBtn');
      const resetButton = document.getElementById('resetBtn');

      let runState = {
        round: 0,
        stageIndex: 0,
        quality: 52,
        token: 0,
        running: false,
        stopReason: '-',
      };

      let autoTimer = null;

      function nowString() {
        const now = new Date();
        return `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;
      }

      function addLog(line) {
        const prefix = `[${nowString()}] `;
        logBox.textContent += `${prefix}${line}\n`;
        logBox.scrollTop = logBox.scrollHeight;
      }

      function syncControlText() {
        controlVals.maxRounds.textContent = controls.maxRounds.value;
        controlVals.qualityThreshold.textContent = controls.qualityThreshold.value;
        controlVals.criticStrength.textContent = Number(controls.criticStrength.value).toFixed(2);
        controlVals.playSpeed.textContent = Number(controls.playSpeed.value).toFixed(2);
      }

      function clearHighlights() {
        Object.values(nodes).forEach((node) => node.classList.remove('active'));
        Object.values(edges).forEach((edge) => edge.classList.remove('active'));
      }

      function markDoneStages() {
        const stagesDone = Math.max(0, runState.round);
        nodes.generator.classList.toggle('done', stagesDone > 0);
        nodes.critic.classList.toggle('done', stagesDone > 0);
        nodes.revise.classList.toggle('done', stagesDone > 0);
      }

      function updateMetrics(stageLabel) {
        metrics.round.textContent = String(runState.round);
        metrics.stage.textContent = stageLabel || 'Idle';
        metrics.quality.textContent = String(Math.min(99, Math.round(runState.quality)));
        metrics.token.textContent = String(Math.round(runState.token));
        metrics.latency.textContent = String(Math.round(180 + runState.token * 0.2 + runState.round * 36));
        metrics.stop.textContent = runState.stopReason;
      }

      function updateStatus(title, content) {
        statusBox.innerHTML = `<strong>${title}</strong><br />${content}`;
      }

      function stopAutoPlay() {
        runState.running = false;
        if (autoTimer) {
          clearInterval(autoTimer);
          autoTimer = null;
        }
        playButton.textContent = 'â–¶ è‡ªåŠ¨æ’­æ”¾';
      }

      function startAutoPlay() {
        if (runState.running) {
          stopAutoPlay();
          return;
        }
        runState.running = true;
        playButton.textContent = 'â¸ æš‚åœ';

        const speed = Number(controls.playSpeed.value);
        const intervalMs = Math.round(900 / Math.max(0.6, speed));
        autoTimer = setInterval(() => {
          const finished = executeStep();
          if (finished) {
            stopAutoPlay();
          }
        }, intervalMs);
      }

      function handleStopDecision() {
        const maxRounds = Number(controls.maxRounds.value);
        const qualityThreshold = Number(controls.qualityThreshold.value);

        if (runState.quality >= qualityThreshold) {
          runState.stopReason = 'è´¨é‡è¾¾æ ‡';
          updateStatus('âœ… åœæ­¢ï¼šè´¨é‡å·²è¾¾é˜ˆå€¼', `å½“å‰è´¨é‡ ${Math.round(runState.quality)} â‰¥ é˜ˆå€¼ ${qualityThreshold}ï¼Œç»“æŸè¿­ä»£ã€‚`);
          addLog(`Stop: quality ${Math.round(runState.quality)} >= threshold ${qualityThreshold}.`);
          updateMetrics('Stop');
          return true;
        }

        if (runState.round >= maxRounds) {
          runState.stopReason = 'è¾¾åˆ°æœ€å¤§è½®æ¬¡';
          updateStatus('ğŸ›‘ åœæ­¢ï¼šè¾¾åˆ°è½®æ¬¡ä¸Šé™', `å½“å‰è½®æ¬¡ ${runState.round}ï¼Œå·²è¾¾åˆ°æœ€å¤§è½®æ¬¡ ${maxRounds}ã€‚`);
          addLog(`Stop: reached max rounds ${maxRounds}.`);
          updateMetrics('Stop');
          return true;
        }

        runState.stopReason = `ç»§ç»­ç¬¬ ${runState.round + 1} è½®`;
        addLog(`Continue: round ${runState.round + 1} starts.`);
        return false;
      }

      function executeStep() {
        const stageName = stages[runState.stageIndex];
        const config = stageConfig[stageName];
        const criticStrength = Number(controls.criticStrength.value);

        clearHighlights();
        nodes[stageName].classList.add('active');
        if (config.edgeId && edges[config.edgeId]) {
          edges[config.edgeId].classList.add('active');
        }

        let qualityGain = config.qualityDelta;
        if (stageName === 'critic') {
          qualityGain *= criticStrength;
        }
        if (stageName === 'revise') {
          qualityGain *= 0.85 + criticStrength * 0.25;
        }

        runState.token += config.tokenDelta;
        runState.quality += qualityGain;

        if (stageName === 'revise') {
          runState.round += 1;
        }

        updateStatus(`${config.label} é˜¶æ®µ`, config.text);
        addLog(`${config.label}: +${config.tokenDelta} tokens, quality +${qualityGain.toFixed(1)}.`);

        markDoneStages();
        updateMetrics(config.label);

        let shouldStop = false;
        if (stageName === 'stop') {
          shouldStop = handleStopDecision();
        }

        runState.stageIndex = (runState.stageIndex + 1) % stages.length;
        reportHeight();
        return shouldStop;
      }

      function resetAll() {
        stopAutoPlay();

        runState = {
          round: 0,
          stageIndex: 0,
          quality: 52,
          token: 0,
          running: false,
          stopReason: '-',
        };

        Object.values(nodes).forEach((node) => {
          node.classList.remove('active');
          node.classList.remove('done');
        });
        Object.values(edges).forEach((edge) => edge.classList.remove('active'));

        logBox.textContent = '';
        addLog('Ready. ç‚¹å‡»â€œå•æ­¥æ‰§è¡Œâ€æˆ–â€œè‡ªåŠ¨æ’­æ”¾â€å¼€å§‹ã€‚');
        updateStatus('å‡†å¤‡å°±ç»ª', 'å½“å‰æ˜¯ Idle çŠ¶æ€ã€‚ä½ å¯ä»¥é€šè¿‡å•æ­¥æ–¹å¼ç†è§£æ¯ä¸ªèŠ‚ç‚¹èŒè´£ï¼Œæˆ–è‡ªåŠ¨æ’­æ”¾è§‚å¯Ÿå®Œæ•´å¤šè½®è¿­ä»£ã€‚');
        updateMetrics('Idle');
        syncControlText();
        reportHeight();
      }

      function bindEvents() {
        stepButton.addEventListener('click', () => {
          const stopped = executeStep();
          if (stopped) {
            stopAutoPlay();
          }
        });

        playButton.addEventListener('click', startAutoPlay);
        resetButton.addEventListener('click', resetAll);

        Object.values(controls).forEach((control) => {
          control.addEventListener('input', () => {
            syncControlText();
            if (control === controls.playSpeed && runState.running) {
              stopAutoPlay();
              startAutoPlay();
            }
            reportHeight();
          });
        });

        window.addEventListener('resize', reportHeight, { passive: true });
        if ('ResizeObserver' in window) {
          const observer = new ResizeObserver(reportHeight);
          observer.observe(document.body);
          observer.observe(document.documentElement);
        }
      }

      function reportHeight() {
        if (window.parent === window) {
          return;
        }

        const body = document.body;
        const root = document.documentElement;
        const h = Math.max(
          body ? body.scrollHeight : 0,
          body ? body.offsetHeight : 0,
          root ? root.scrollHeight : 0,
          root ? root.offsetHeight : 0
        );

        window.parent.postMessage({ type: 'iframe-height', height: h }, '*');
      }

      function init() {
        bindEvents();
        resetAll();
        setTimeout(reportHeight, 100);
        setTimeout(reportHeight, 450);
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init, { once: true });
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
